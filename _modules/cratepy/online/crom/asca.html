<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>cratepy.online.crom.asca &mdash; CRATE 1.0.3 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/readthedocs-custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/sphinx_highlight.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            CRATE
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/getting_started/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/getting_started/run_benchmark.html">Run a benchmark</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Basic usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/basic_usage/general_workflow.html">General workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/basic_usage/step1_material_model.html">Step 1: Material model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/basic_usage/step2_input_data.html">Step 2: Input data file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/basic_usage/step3_simulation.html">Step 3: Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/basic_usage/step4_post_processing.html">Step 4: Post-processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/basic_usage/available_features.html">Available features</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Validation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/validation/benchmarks.html">Benchmarks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/advanced_usage/customization.html">Customization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/advanced_usage/interface_dns_solver.html">Interface: DNS solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/advanced_usage/interface_clustering_feature.html">Interface: Clustering feature</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/advanced_usage/interface_clustering_algorithm.html">Interface: Clustering algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/advanced_usage/interface_constitutive_model.html">Interface: Constitutive model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../rst_doc_files/reference/index.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../_autosummary/cratepy.html">Code</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">License</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../license.html">BSD 3-Clause License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">CRATE</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">cratepy.online.crom.asca</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for cratepy.online.crom.asca</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Adaptive Self-consistent Clustering Analysis (ASCA).</span>

<span class="sd">This module includes the implementation of the Adaptive Self-consistent</span>
<span class="sd">Clustering Analysis (ASCA), a clustering-based reduced-order model proposed by</span>
<span class="sd">Ferreira et. al (2022) [#]_. Under infinitesimal strains, the Self-consistent</span>
<span class="sd">Clustering Analysis (SCA) proposed by Liu et. al (2016) [#]_ is recovered in</span>
<span class="sd">the absence of clustering adaptivity.</span>

<span class="sd">.. [#] Ferreira, B.P., Andrade Pires, F.M. and Bessa, M.A. (2022).</span>
<span class="sd">       *Adaptivity for clustering-based reduced-order modeling of</span>
<span class="sd">       localized history-dependent phenomena.* Comp Methods Appl M, 393</span>
<span class="sd">       (see `here &lt;https://www.sciencedirect.com/science/article/pii/</span>
<span class="sd">       S0045782522000895?via%3Dihub&gt;`_)</span>

<span class="sd">.. [#] Liu, Z., Bessa, M., and Liu, W.K. (2016).</span>
<span class="sd">       *Self-consistent clustering analysis: An efficient multi-scale scheme</span>
<span class="sd">       for inelastic heterogeneous materials.* Comp Methods Appl M, 396:319-341</span>
<span class="sd">       (see `here &lt;https://www.sciencedirect.com/science/article/pii/</span>
<span class="sd">       S0045782516301499&gt;`_)</span>

<span class="sd">The finite strain extension compatible with multiplicative kinematics of both</span>
<span class="sd">SCA and ASCA methods is also available as proposed by Ferreira (2022) [#]_</span>
<span class="sd">(see Sections 4.7-4.9). However, the development of an accurate self-consistent</span>
<span class="sd">scheme compatible with such as a formulation is still under investigation (see</span>
<span class="sd">Section 4.9).</span>

<span class="sd">.. [#] Ferreira, B.P. (2022). *Towards Data-driven Multi-scale</span>
<span class="sd">       Optimization of Thermoplastic Blends: Microstructural</span>
<span class="sd">       Generation, Constitutive Development and Clustering-based</span>
<span class="sd">       Reduced-Order Modeling.* PhD Thesis, University of Porto</span>
<span class="sd">       (see `here &lt;https://repositorio-aberto.up.pt/handle/10216/</span>
<span class="sd">       146900?locale=en&gt;`_)</span>

<span class="sd">Besides the main class that implements the aforementioned methods, this</span>
<span class="sd">module also includes a class associated with the reference (fictitious)</span>
<span class="sd">homogeneous material, which arises in the formulation of the SCA and ASCA,</span>
<span class="sd">and an interface to implement any self-consistent scheme, required to determine</span>
<span class="sd">the properties of such a reference material.</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>
<span class="sd">ASCA</span>
<span class="sd">    Adaptive Self-Consistent Clustering Analysis (ASCA).</span>
<span class="sd">ReferenceMaterialOptimizer(ABC)</span>
<span class="sd">    Elastic reference material properties optimizer interface.</span>
<span class="sd">InfinitesimalRegressionSCS(ReferenceMaterialOptimizer)</span>
<span class="sd">    Infinitesimal strains format regression-based self-consistent scheme.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#                                                                       Modules</span>
<span class="c1"># =============================================================================</span>
<span class="c1"># Standard</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="c1"># Third-party</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.matlib</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="c1"># Local</span>
<span class="kn">import</span> <span class="nn">ioput.info</span> <span class="k">as</span> <span class="nn">info</span>
<span class="kn">import</span> <span class="nn">tensor.matrixoperations</span> <span class="k">as</span> <span class="nn">mop</span>
<span class="kn">import</span> <span class="nn">tensor.tensoroperations</span> <span class="k">as</span> <span class="nn">top</span>
<span class="kn">from</span> <span class="nn">clustering.citoperations</span> <span class="kn">import</span> <span class="n">assemble_cit</span>
<span class="kn">from</span> <span class="nn">online.loading.macloadincrem</span> <span class="kn">import</span> <span class="n">LoadingPath</span><span class="p">,</span> <span class="n">IncrementRewinder</span><span class="p">,</span> \
                                         <span class="n">RewindManager</span>
<span class="kn">from</span> <span class="nn">clustering.adaptivity.crve_adaptivity</span> <span class="kn">import</span> <span class="n">AdaptivityManager</span><span class="p">,</span> \
                                                  <span class="n">ClusteringAdaptivityOutput</span>
<span class="kn">from</span> <span class="nn">ioput.incoutputfiles.homresoutput</span> <span class="kn">import</span> <span class="n">HomResOutput</span>
<span class="kn">from</span> <span class="nn">ioput.incoutputfiles.efftanoutput</span> <span class="kn">import</span> <span class="n">EffTanOutput</span>
<span class="kn">from</span> <span class="nn">ioput.incoutputfiles.refmatoutput</span> <span class="kn">import</span> <span class="n">RefMatOutput</span>
<span class="kn">from</span> <span class="nn">ioput.miscoutputfiles.vtkoutput</span> <span class="kn">import</span> <span class="n">VTKOutput</span>
<span class="kn">from</span> <span class="nn">ioput.miscoutputfiles.voxelsoutput</span> <span class="kn">import</span> <span class="n">VoxelsOutput</span>
<span class="c1">#</span>
<span class="c1">#                                                          Authorship &amp; Credits</span>
<span class="c1"># =============================================================================</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Bernardo Ferreira (bernardo_ferreira@brown.edu)&#39;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Bernardo Ferreira&#39;</span><span class="p">,</span> <span class="p">]</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s1">&#39;Stable&#39;</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="ASCA"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA">[docs]</a><span class="k">class</span> <span class="nc">ASCA</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adaptive Self-Consistent Clustering Analysis (ASCA).</span>

<span class="sd">    The detailed formulation of this method can be found in</span>
<span class="sd">    Ferreira et. al (2022) [#]_ and also in Ferreira (2022) [#]_.</span>

<span class="sd">    .. [#] Ferreira, B.P., Andrade Pires, F.M. and Bessa, M.A. (2022).</span>
<span class="sd">           *Adaptivity for clustering-based reduced-order modeling of</span>
<span class="sd">           localized history-dependent phenomena.* Comp Methods Appl M, 393</span>
<span class="sd">           (see `here &lt;https://www.sciencedirect.com/science/article/pii/</span>
<span class="sd">           S0045782522000895?via%3Dihub&gt;`_)</span>

<span class="sd">    .. [#] Ferreira, B.P. (2022). *Towards Data-driven Multi-scale</span>
<span class="sd">           Optimization of Thermoplastic Blends: Microstructural</span>
<span class="sd">           Generation, Constitutive Development and Clustering-based</span>
<span class="sd">           Reduced-Order Modeling.* PhD Thesis, University of Porto</span>
<span class="sd">           (see `here &lt;https://repositorio-aberto.up.pt/handle/10216/</span>
<span class="sd">           146900?locale=en&gt;`_)</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _n_dim : int</span>
<span class="sd">        Problem number of spatial dimensions.</span>
<span class="sd">    _comp_order_sym : list[str]</span>
<span class="sd">        Strain/Stress components symmetric order.</span>
<span class="sd">    _comp_order_nsym : list[str]</span>
<span class="sd">        Strain/Stress components nonsymmetric order.</span>
<span class="sd">    _global_strain_old_mf : numpy.ndarray (1d)</span>
<span class="sd">        Last converged global vector of clusters strains stored in matricial</span>
<span class="sd">        form.</span>
<span class="sd">    _farfield_strain_old_mf : numpy.ndarray (1d), default=None</span>
<span class="sd">        Last converged far-field strain tensor (matricial form).</span>
<span class="sd">    _total_time : float</span>
<span class="sd">        Total time (s) associated with online-stage.</span>
<span class="sd">    _effective_time : float</span>
<span class="sd">        Total time (s) associated with the solution of the equilibrium problem.</span>
<span class="sd">    _post_process_time : float</span>
<span class="sd">        Total time (s) associated with post-processing operations.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    get_time_profile(self)</span>
<span class="sd">        Get time profile of online-stage.</span>
<span class="sd">    solve_equilibrium_problem(self, crve, material_state, mac_load, \</span>
<span class="sd">                              mac_load_presctype, mac_load_increm, \</span>
<span class="sd">                              output_dir, problem_name=&#39;problem&#39;, \</span>
<span class="sd">                              clust_adapt_freq=None, \</span>
<span class="sd">                              is_solution_rewinding=False, \</span>
<span class="sd">                              rewind_state_criterion=None, \</span>
<span class="sd">                              rewinding_criterion=None, max_n_rewinds=1, \</span>
<span class="sd">                              is_clust_adapt_output=False, \</span>
<span class="sd">                              is_ref_material_output=False, \</span>
<span class="sd">                              is_vtk_output=False, \</span>
<span class="sd">                              vtk_data=None, is_voxels_output=False)</span>
<span class="sd">        Solve clustering-based reduced-order equilibrium problem.</span>
<span class="sd">    _init_global_strain_mf(self, mode=&#39;last_converged&#39;)</span>
<span class="sd">        Set clusters strains initial iterative guess.</span>
<span class="sd">    _init_global_inc_strain_mf(self, n_total_clusters, mode=&#39;last_converged&#39;)</span>
<span class="sd">        Set clusters incremental strains initial iterative guess.</span>
<span class="sd">    _init_farfield_strain_mf(self, mode=&#39;last_converged&#39;)</span>
<span class="sd">        Set far-field strain initial iterative guess.</span>
<span class="sd">    _init_inc_farfield_strain_mf(self, mode=&#39;last_converged&#39;)</span>
<span class="sd">        Set incremental far-field strain initial iterative guess.</span>
<span class="sd">    _build_residual(self, crve, material_state, presc_strain_idxs, \</span>
<span class="sd">                    presc_stress_idxs, applied_mac_load_mf, ref_material, \</span>
<span class="sd">                    global_cit_mf, global_strain_mf, farfield_strain_mf=None, \</span>
<span class="sd">                    applied_mix_strain_mf=None, applied_mix_stress_mf=None)</span>
<span class="sd">        Build Lippmann-Schwinger equilibrium residuals.</span>
<span class="sd">    _build_jacobian(self, crve, material_state, presc_strain_idxs, \</span>
<span class="sd">                    presc_stress_idxs, global_cit_diff_tangent_mf)</span>
<span class="sd">        Build Lippmann-Schwinger equilibrium Jacobian matrix.</span>
<span class="sd">    _build_global_cit_diff_tangent_mf(self, crve, global_cit_mf, \</span>
<span class="sd">                                      material_state, ref_material)</span>
<span class="sd">        Build global cluster interaction - tangent modulus matrix.</span>
<span class="sd">    _check_convergence(self, crve, material_state, presc_strain_idxs, \</span>
<span class="sd">                       presc_stress_idxs, applied_mac_load_mf, residual, \</span>
<span class="sd">                       applied_mix_strain_mf=None)</span>
<span class="sd">        Check Lippmann-Schwinger equilibrium convergence.</span>
<span class="sd">    _crve_effective_tangent_modulus(self, crve, material_state, \</span>
<span class="sd">                                    global_cit_diff_tangent_mf, \</span>
<span class="sd">                                    global_strain_mf=None, \</span>
<span class="sd">                                    farfield_strain_mf=None)</span>
<span class="sd">        CRVE tangent modulus and clusters strain concentration tensors.</span>
<span class="sd">    _validate_csct(self, material_phases, phase_clusters, global_csct_mf, \</span>
<span class="sd">                   global_strain_mf, farfield_strain_mf)</span>
<span class="sd">        Validate clusters strain concentration tensors computation.</span>
<span class="sd">    _init_clusters_sct(self, material_phases, phase_clusters)</span>
<span class="sd">        Initialize cluster strain concentration tensors.</span>
<span class="sd">    _build_clusters_residuals(self, material_phases, phase_clusters, residual)</span>
<span class="sd">        Build clusters equilibrium residuals dictionary.</span>
<span class="sd">    _display_inc_data(mac_load_path)</span>
<span class="sd">        Display loading increment data.</span>
<span class="sd">    _display_scs_iter_data(ref_material, is_lock_prop_ref, mode=&#39;init&#39;, \</span>
<span class="sd">                           scs_iter_time=None)</span>
<span class="sd">        Display reference material self-consistent scheme iteration data.</span>
<span class="sd">    _display_nr_iter_data(mode=&#39;init&#39;, nr_iter=None, nr_iter_time=None, \</span>
<span class="sd">                          errors=[])</span>
<span class="sd">        Display Newton-Raphson iteration data.</span>
<span class="sd">    _set_output_files(self, output_dir, crve, problem_name=&#39;problem&#39;, \</span>
<span class="sd">                      is_clust_adapt_output=False, \</span>
<span class="sd">                      is_ref_material_output=None, \</span>
<span class="sd">                      is_vtk_output=False, vtk_data=None, \</span>
<span class="sd">                      is_voxels_output=None)</span>
<span class="sd">        Create and initialize output files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ASCA.__init__"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span>
                 <span class="n">self_consistent_scheme</span><span class="o">=</span><span class="s1">&#39;regression&#39;</span><span class="p">,</span> <span class="n">scs_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">scs_max_n_iterations</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">scs_conv_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
                 <span class="n">max_n_iterations</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">conv_tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">max_subinc_level</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                 <span class="n">max_cinc_cuts</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">is_adapt_repeat_inc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Problem strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        self_consistent_scheme : {&#39;regression&#39;,}, default=&#39;regression&#39;</span>
<span class="sd">            Self-consistent scheme to update the elastic reference material</span>
<span class="sd">            properties.</span>
<span class="sd">        scs_parameters : {dict, None}, default=None</span>
<span class="sd">            Self-consistent scheme parameters (key, str; item,</span>
<span class="sd">            {int, float, bool}).</span>
<span class="sd">        scs_max_n_iterations : int, default=20</span>
<span class="sd">            Self-consistent scheme maximum number of iterations.</span>
<span class="sd">        scs_conv_tol : float, default=1e-4</span>
<span class="sd">            Self-consistent scheme convergence tolerance.</span>
<span class="sd">        max_n_iterations : int, default=12</span>
<span class="sd">            Newton-Raphson maximum number of iterations.</span>
<span class="sd">        conv_tol : float, default=1e-6</span>
<span class="sd">            Newton-Raphson convergence tolerance.</span>
<span class="sd">        max_subinc_level : int, default=5</span>
<span class="sd">            Maximum level of loading subincrementation.</span>
<span class="sd">        max_cinc_cuts : int, default=5</span>
<span class="sd">            Maximum number of consecutive increment cuts.</span>
<span class="sd">        is_adapt_repeat_inc : bool, default=False</span>
<span class="sd">            True if loading increment is to be repeated after a clustering</span>
<span class="sd">            adaptivity step, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">=</span> <span class="n">strain_formulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span> <span class="o">=</span> <span class="n">problem_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_self_consistent_scheme</span> <span class="o">=</span> <span class="n">self_consistent_scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scs_parameters</span> <span class="o">=</span> <span class="n">scs_parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scs_max_n_iterations</span> <span class="o">=</span> <span class="n">scs_max_n_iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scs_conv_tol</span> <span class="o">=</span> <span class="n">scs_conv_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_n_iterations</span> <span class="o">=</span> <span class="n">max_n_iterations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conv_tol</span> <span class="o">=</span> <span class="n">conv_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_subinc_level</span> <span class="o">=</span> <span class="n">max_subinc_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_cinc_cuts</span> <span class="o">=</span> <span class="n">max_cinc_cuts</span>
        <span class="c1"># Get problem type parameters</span>
        <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">comp_order_nsym</span> <span class="o">=</span> \
            <span class="n">mop</span><span class="o">.</span><span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">=</span> <span class="n">n_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span> <span class="o">=</span> <span class="n">comp_order_sym</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span> <span class="o">=</span> <span class="n">comp_order_nsym</span>
        <span class="c1"># Initialize last converged algorithmic variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_global_strain_old_mf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_farfield_strain_old_mf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Initialize times</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_total_time</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_effective_time</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_post_process_time</span> <span class="o">=</span> <span class="mf">0.0</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA.get_time_profile"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA.get_time_profile">[docs]</a>    <span class="k">def</span> <span class="nf">get_time_profile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get time profile of online-stage.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_time : float</span>
<span class="sd">            Total time (s) associated with online-stage.</span>
<span class="sd">        effective_time : float</span>
<span class="sd">            Total time (s) associated with the solution of the equilibrium</span>
<span class="sd">            problem.</span>
<span class="sd">        post_process_time : float</span>
<span class="sd">            Total time (s) associated with post-processing operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_effective_time</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_process_time</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA.solve_equilibrium_problem"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA.solve_equilibrium_problem">[docs]</a>    <span class="k">def</span> <span class="nf">solve_equilibrium_problem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crve</span><span class="p">,</span> <span class="n">material_state</span><span class="p">,</span> <span class="n">mac_load</span><span class="p">,</span>
                                  <span class="n">mac_load_presctype</span><span class="p">,</span> <span class="n">mac_load_increm</span><span class="p">,</span>
                                  <span class="n">output_dir</span><span class="p">,</span> <span class="n">problem_name</span><span class="o">=</span><span class="s1">&#39;problem&#39;</span><span class="p">,</span>
                                  <span class="n">clust_adapt_freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">is_solution_rewinding</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">rewind_state_criterion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                  <span class="n">rewinding_criterion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_n_rewinds</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                  <span class="n">is_clust_adapt_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">is_ref_material_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">is_vtk_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="n">vtk_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_voxels_output</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solve clustering-based reduced-order equilibrium problem.</span>

<span class="sd">        The overall solution procedure of the Self-consistent Clustering</span>
<span class="sd">        Analysis (SCA) under infinitesimal strains is summarized in Boxes C.2</span>
<span class="sd">        (Newton-Raphson iterative scheme) and C.3 (self-consistent iterative</span>
<span class="sd">        scheme) of Ferreira (2022) [#]_. The finite strain extension compatible</span>
<span class="sd">        with multiplicative kinematics can be found in Box 4.2 (Newton-Raphson</span>
<span class="sd">        iterative scheme) and the enrichement with clustering adaptivity</span>
<span class="sd">        (Adaptive Self-consistent Clustering Analysis (ASCA)) is described in</span>
<span class="sd">        Section 4.4.</span>

<span class="sd">        .. [#] Ferreira, B.P. (2022). *Towards Data-driven Multi-scale</span>
<span class="sd">               Optimization of Thermoplastic Blends: Microstructural</span>
<span class="sd">               Generation, Constitutive Development and Clustering-based</span>
<span class="sd">               Reduced-Order Modeling.* PhD Thesis, University of Porto</span>
<span class="sd">               (see `here &lt;https://repositorio-aberto.up.pt/handle/10216/</span>
<span class="sd">               146900?locale=en&gt;`_)</span>

<span class="sd">        ----</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crve : CRVE</span>
<span class="sd">            Cluster-Reduced Representative Volume Element.</span>
<span class="sd">        material_state : MaterialState</span>
<span class="sd">            CRVE material constitutive state.</span>
<span class="sd">        mac_load : dict</span>
<span class="sd">            For each loading nature type (key, {&#39;strain&#39;, &#39;stress&#39;}), stores</span>
<span class="sd">            the loading constraints for each loading subpath in a</span>
<span class="sd">            numpy.ndarray (2d), where the i-th row is associated with the i-th</span>
<span class="sd">            strain/stress component and the j-th column is associated with the</span>
<span class="sd">            j-th loading subpath.</span>
<span class="sd">        mac_load_presctype : numpy.ndarray (2d)</span>
<span class="sd">            Loading nature type ({&#39;strain&#39;, &#39;stress&#39;}) associated with each</span>
<span class="sd">            loading constraint (numpy.ndarray of shape</span>
<span class="sd">            (n_comps, n_load_subpaths)), where the i-th row is associated with</span>
<span class="sd">            the i-th strain/stress component and the j-th column is associated</span>
<span class="sd">            with the j-th loading subpath.</span>
<span class="sd">        mac_load_increm : dict</span>
<span class="sd">            For each loading subpath id (key, str), stores a numpy.ndarray of</span>
<span class="sd">            shape (n_load_increments, 2) where each row is associated with a</span>
<span class="sd">            prescribed loading increment, and the columns 0 and 1 contain the</span>
<span class="sd">            corresponding incremental load factor and incremental time,</span>
<span class="sd">            respectively.</span>
<span class="sd">        output_dir : str</span>
<span class="sd">            Absolute directory path of output files.</span>
<span class="sd">        problem_name : str, default=&#39;problem&#39;</span>
<span class="sd">            Problem name.</span>
<span class="sd">        clust_adapt_freq : dict, default=None</span>
<span class="sd">            Clustering adaptivity frequency (relative to loading</span>
<span class="sd">            incrementation) (item, int) associated with each adaptive</span>
<span class="sd">            cluster-reduced material phase (key, str).</span>
<span class="sd">        is_solution_rewinding : bool, default=False</span>
<span class="sd">            Problem solution rewinding flag.</span>
<span class="sd">        rewind_state_criterion : tuple, default=None</span>
<span class="sd">            Rewind state storage criterion [0] and associated parameter [1].</span>
<span class="sd">        rewinding_criterion : tuple, default=None</span>
<span class="sd">            Rewinding criterion [0] and associated parameter [1].</span>
<span class="sd">        max_n_rewinds : int, default=1</span>
<span class="sd">            Maximum number of rewind operations.</span>
<span class="sd">        is_clust_adapt_output : bool, default=False</span>
<span class="sd">            Clustering adaptivity output flag.</span>
<span class="sd">        is_ref_material_output : bool, default=False</span>
<span class="sd">            Reference material output flag.</span>
<span class="sd">        is_vtk_output : bool, default=False</span>
<span class="sd">            VTK output flag.</span>
<span class="sd">        vtk_data : dict, default=None</span>
<span class="sd">            VTK output file parameters.</span>
<span class="sd">        is_voxels_output : bool</span>
<span class="sd">            Voxels output file flag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="c1">#                                                       Initializations</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set online-stage initial time</span>
        <span class="n">init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Initialize online-stage post-processing time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_post_process_time</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set default strain/stress components order according to problem</span>
        <span class="c1"># strain formulation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown problem strain formulation.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize loading increment cut flag</span>
        <span class="n">is_inc_cut</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Initialize improved cluster incremental strains initial iterative</span>
        <span class="c1"># guess flag</span>
        <span class="n">is_improved_init_guess</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize global vector of clusters strain tensors and far-field</span>
        <span class="c1"># strain tensor</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="c1"># Set clusters infinitesimal strain tensors</span>
            <span class="n">global_strain_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="n">crve</span><span class="o">.</span><span class="n">get_n_total_clusters</span><span class="p">()</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span><span class="p">)))</span>
            <span class="c1"># Set far-field strain tensor</span>
            <span class="n">farfield_strain_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Set initialized deformation gradient (matricial form)</span>
            <span class="n">def_gradient_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="mf">0.0</span>
                                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span><span class="p">])</span>
            <span class="c1"># Build clusters deformation gradients</span>
            <span class="n">global_strain_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">def_gradient_mf</span><span class="p">,</span>
                                       <span class="n">crve</span><span class="o">.</span><span class="n">get_n_total_clusters</span><span class="p">())</span>
            <span class="c1"># Set far-field strain tensor</span>
            <span class="n">farfield_strain_mf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">def_gradient_mf</span><span class="p">)</span>
        <span class="c1"># Initialize last converged algorithmic variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_global_strain_old_mf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">global_strain_mf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_farfield_strain_old_mf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">farfield_strain_mf</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize clustering adaptivity flag</span>
        <span class="n">is_crve_adaptivity</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">adaptivity_manager</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">crve</span><span class="o">.</span><span class="n">get_adapt_material_phases</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Switch on clustering adaptivity flag</span>
            <span class="n">is_crve_adaptivity</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set flag that controls if the macroscale loading increment where</span>
            <span class="c1"># the clustering adaptivity is triggered is to be repeated</span>
            <span class="c1"># considering the new clustering</span>
            <span class="n">is_adapt_repeat_inc</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set clustering adaptivity frequency default</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clust_adapt_freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_clust_adapt_freq</span> <span class="o">=</span> <span class="p">{</span><span class="n">mat_phase</span><span class="p">:</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">mat_phase</span>
                                          <span class="ow">in</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_adapt_material_phases</span><span class="p">()}</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Initialize clustering adaptivity manager</span>
            <span class="n">adaptivity_manager</span> <span class="o">=</span> <span class="n">AdaptivityManager</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">,</span>
                <span class="n">crve</span><span class="o">.</span><span class="n">get_adapt_material_phases</span><span class="p">(),</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_phase_clusters</span><span class="p">(),</span>
                <span class="n">crve</span><span class="o">.</span><span class="n">get_adaptivity_control_feature</span><span class="p">(),</span>
                <span class="n">crve</span><span class="o">.</span><span class="n">get_adapt_criterion_data</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clust_adapt_freq</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize increment rewinder manager</span>
        <span class="k">if</span> <span class="n">is_solution_rewinding</span><span class="p">:</span>
            <span class="c1"># Initialize increment rewinder manager</span>
            <span class="n">rewind_manager</span> <span class="o">=</span> <span class="n">RewindManager</span><span class="p">(</span>
                <span class="n">rewind_state_criterion</span><span class="o">=</span><span class="n">rewind_state_criterion</span><span class="p">,</span>
                <span class="n">rewinding_criterion</span><span class="o">=</span><span class="n">rewinding_criterion</span><span class="p">,</span>
                <span class="n">max_n_rewinds</span><span class="o">=</span><span class="n">max_n_rewinds</span><span class="p">)</span>
            <span class="c1"># Initialize increment rewinder flag</span>
            <span class="n">is_inc_rewinder</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize clusters state variables</span>
        <span class="n">material_state</span><span class="o">.</span><span class="n">init_clusters_state</span><span class="p">()</span>
        <span class="c1"># Initialize clusters strain concentration tensors</span>
        <span class="n">clusters_sct_mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_clusters_sct</span><span class="p">(</span>
            <span class="n">material_state</span><span class="o">.</span><span class="n">get_material_phases</span><span class="p">(),</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_phase_clusters</span><span class="p">())</span>
        <span class="n">clusters_sct_old_mf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">clusters_sct_mf</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="c1">#                                                          Output files</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set post-processing procedure initial time</span>
        <span class="n">procedure_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Create and initialize output files</span>
        <span class="n">hres_output</span><span class="p">,</span> <span class="n">efftan_output</span><span class="p">,</span> <span class="n">ref_mat_output</span><span class="p">,</span> <span class="n">voxels_output</span><span class="p">,</span> \
            <span class="n">adapt_output</span><span class="p">,</span> <span class="n">vtk_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_output_files</span><span class="p">(</span>
                <span class="n">output_dir</span><span class="p">,</span> <span class="n">crve</span><span class="p">,</span> <span class="n">problem_name</span><span class="o">=</span><span class="n">problem_name</span><span class="p">,</span>
                <span class="n">is_clust_adapt_output</span><span class="o">=</span><span class="n">is_clust_adapt_output</span><span class="p">,</span>
                <span class="n">is_ref_material_output</span><span class="o">=</span><span class="n">is_ref_material_output</span><span class="p">,</span>
                <span class="n">is_vtk_output</span><span class="o">=</span><span class="n">is_vtk_output</span><span class="p">,</span> <span class="n">vtk_data</span><span class="o">=</span><span class="n">vtk_data</span><span class="p">,</span>
                <span class="n">is_voxels_output</span><span class="o">=</span><span class="n">is_voxels_output</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">if</span> <span class="n">is_vtk_output</span><span class="p">:</span>
            <span class="c1"># Write VTK file associated with the initial state</span>
            <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;18&#39;</span><span class="p">)</span>
            <span class="n">vtk_output</span><span class="o">.</span><span class="n">write_vtk_file_time_step</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">,</span> <span class="n">crve</span><span class="p">,</span>
                <span class="n">material_state</span><span class="p">,</span> <span class="n">vtk_vars</span><span class="o">=</span><span class="n">vtk_data</span><span class="p">[</span><span class="s1">&#39;vtk_vars&#39;</span><span class="p">],</span>
                <span class="n">adaptivity_manager</span><span class="o">=</span><span class="n">adaptivity_manager</span><span class="p">)</span>
            <span class="c1"># Get VTK output increment divider</span>
            <span class="n">vtk_inc_div</span> <span class="o">=</span> <span class="n">vtk_data</span><span class="p">[</span><span class="s1">&#39;vtk_inc_div&#39;</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Increment post-processing time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_post_process_time</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">procedure_init_time</span>
        <span class="c1">#</span>
        <span class="c1">#                                            Elastic reference material</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Instantiate elastic reference material</span>
        <span class="n">ref_material</span> <span class="o">=</span> <span class="n">ElasticReferenceMaterial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">_self_consistent_scheme</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">_scs_conv_tol</span><span class="p">)</span>
        <span class="c1"># Initialize initial value of elastic reference material properties</span>
        <span class="n">scs_init_properties</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Get initial value of elastic reference material properties</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scs_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="p">{</span><span class="s1">&#39;E_init&#39;</span><span class="p">,</span> <span class="s1">&#39;v_init&#39;</span><span class="p">}</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_scs_parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="c1"># Get properties specifications</span>
            <span class="n">spec_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scs_parameters</span><span class="p">[</span><span class="s1">&#39;E_init&#39;</span><span class="p">]</span>
            <span class="n">spec_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scs_parameters</span><span class="p">[</span><span class="s1">&#39;v_init&#39;</span><span class="p">]</span>
            <span class="c1"># Get properties</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">spec_1</span> <span class="o">==</span> <span class="s1">&#39;init_eff_tangent&#39;</span> <span class="ow">and</span> <span class="n">spec_2</span> <span class="o">==</span> <span class="s1">&#39;init_eff_tangent&#39;</span><span class="p">):</span>
                <span class="n">scs_init_properties</span> <span class="o">=</span> \
                    <span class="n">crve</span><span class="o">.</span><span class="n">get_eff_isotropic_elastic_constants</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scs_init_properties</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">scs_init_properties</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scs_parameters</span><span class="p">[</span><span class="s1">&#39;E_init&#39;</span><span class="p">]</span>
                <span class="n">scs_init_properties</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scs_parameters</span><span class="p">[</span><span class="s1">&#39;v_init&#39;</span><span class="p">]</span>
        <span class="c1"># Set initial value of elastic reference material properties</span>
        <span class="n">ref_material</span><span class="o">.</span><span class="n">init_material_properties</span><span class="p">(</span>
            <span class="n">material_state</span><span class="o">.</span><span class="n">get_material_phases</span><span class="p">(),</span>
            <span class="n">material_state</span><span class="o">.</span><span class="n">get_material_phases_properties</span><span class="p">(),</span>
            <span class="n">material_state</span><span class="o">.</span><span class="n">get_material_phases_vf</span><span class="p">(),</span>
            <span class="n">properties</span><span class="o">=</span><span class="n">scs_init_properties</span><span class="p">)</span>
        <span class="c1"># Initialize reference material elastic properties locking flag</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_self_consistent_scheme</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="n">is_lock_prop_ref</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_lock_prop_ref</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">#</span>
        <span class="c1">#                                                          Loading path</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Instantiate macroscale loading path</span>
        <span class="n">mac_load_path</span> <span class="o">=</span> <span class="n">LoadingPath</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">,</span> <span class="n">mac_load</span><span class="p">,</span>
            <span class="n">mac_load_presctype</span><span class="p">,</span> <span class="n">mac_load_increm</span><span class="p">,</span>
            <span class="n">max_subinc_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_subinc_level</span><span class="p">,</span>
            <span class="n">max_cinc_cuts</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_cinc_cuts</span><span class="p">)</span>
        <span class="c1"># Set initial homogenized state</span>
        <span class="n">mac_load_path</span><span class="o">.</span><span class="n">update_hom_state</span><span class="p">(</span><span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_strain_mf</span><span class="p">(),</span>
                                       <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_stress_mf</span><span class="p">())</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get increment counter</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">mac_load_path</span><span class="o">.</span><span class="n">get_increm_state</span><span class="p">()[</span><span class="s1">&#39;inc&#39;</span><span class="p">]</span>
        <span class="c1"># Save macroscale loading increment (converged) state</span>
        <span class="k">if</span> <span class="n">is_solution_rewinding</span> <span class="ow">and</span> <span class="n">rewind_manager</span><span class="o">.</span><span class="n">is_rewind_available</span><span class="p">()</span> \
                <span class="ow">and</span> <span class="n">rewind_manager</span><span class="o">.</span><span class="n">is_save_rewind_state</span><span class="p">(</span><span class="n">inc</span><span class="p">):</span>
            <span class="c1"># Set reference rewind time</span>
            <span class="n">rewind_manager</span><span class="o">.</span><span class="n">update_rewind_time</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
            <span class="c1"># Instantiate increment rewinder</span>
            <span class="n">inc_rewinder</span> <span class="o">=</span> <span class="n">IncrementRewinder</span><span class="p">(</span>
                <span class="n">rewind_inc</span><span class="o">=</span><span class="n">inc</span><span class="p">,</span> <span class="n">phase_clusters</span><span class="o">=</span><span class="n">crve</span><span class="o">.</span><span class="n">get_phase_clusters</span><span class="p">())</span>
            <span class="c1"># Save loading path state</span>
            <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">save_loading_path</span><span class="p">(</span><span class="n">loading_path</span><span class="o">=</span><span class="n">mac_load_path</span><span class="p">)</span>
            <span class="c1"># Save material constitutive state</span>
            <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">save_material_state</span><span class="p">(</span><span class="n">material_state</span><span class="p">)</span>
            <span class="c1"># Save elastic reference material</span>
            <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">save_reference_material</span><span class="p">(</span><span class="n">ref_material</span><span class="p">)</span>
            <span class="c1"># Save clusters strain concentration tensors</span>
            <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">save_clusters_sct</span><span class="p">(</span><span class="n">clusters_sct_mf</span><span class="p">)</span>
            <span class="c1"># Save algorithmic variables</span>
            <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">save_asca_algorithmic_variables</span><span class="p">(</span><span class="n">global_strain_mf</span><span class="p">,</span>
                                                         <span class="n">farfield_strain_mf</span><span class="p">)</span>
            <span class="c1"># Set increment rewinder flag</span>
            <span class="n">is_inc_rewinder</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Setup first macroscale loading increment</span>
        <span class="n">applied_mac_load_mf</span><span class="p">,</span> <span class="n">inc_mac_load_mf</span><span class="p">,</span> <span class="n">n_presc_strain</span><span class="p">,</span> \
            <span class="n">presc_strain_idxs</span><span class="p">,</span> <span class="n">n_presc_stress</span><span class="p">,</span> <span class="n">presc_stress_idxs</span><span class="p">,</span> \
            <span class="n">is_last_inc</span> <span class="o">=</span> <span class="n">mac_load_path</span><span class="o">.</span><span class="n">new_load_increment</span><span class="p">()</span>
        <span class="c1"># Get increment counter</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">mac_load_path</span><span class="o">.</span><span class="n">get_increm_state</span><span class="p">()[</span><span class="s1">&#39;inc&#39;</span><span class="p">]</span>
        <span class="c1"># Display increment data</span>
        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_display_inc_data</span><span class="p">(</span><span class="n">mac_load_path</span><span class="p">)</span>
        <span class="c1"># Set increment initial time</span>
        <span class="n">inc_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># ---------------------------------------------------------------------</span>
        <span class="c1"># Start incremental loading loop</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1">#</span>
            <span class="c1">#                           Clusters strain initial iterative guess</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set clusters strain initial iterative guess</span>
            <span class="n">global_strain_mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_global_strain_mf</span><span class="p">()</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set far-field strain initial iterative guess</span>
            <span class="n">farfield_strain_mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_farfield_strain_mf</span><span class="p">()</span>
            <span class="c1">#</span>
            <span class="c1">#                             Self-consistent scheme iterative loop</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Initialize self-consistent scheme iteration counter</span>
            <span class="n">ref_material</span><span class="o">.</span><span class="n">init_scs_iter</span><span class="p">()</span>
            <span class="c1"># Display reference material self-consistent scheme iteration data</span>
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_display_scs_iter_data</span><span class="p">(</span><span class="n">ref_material</span><span class="p">,</span> <span class="n">is_lock_prop_ref</span><span class="p">,</span>
                                              <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
            <span class="c1"># Set self-consistent scheme iteration initial time</span>
            <span class="n">scs_iter_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="c1"># -----------------------------------------------------------------</span>
            <span class="c1"># Start self-consistent scheme iterative loop</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1">#</span>
                <span class="c1">#                    Global cluster interaction matrix assembly</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Update cluster interaction tensors with elastic reference</span>
                <span class="c1"># material properties and assemble global cluster interaction</span>
                <span class="c1"># matrix</span>
                <span class="n">global_cit_mf</span> <span class="o">=</span> <span class="n">assemble_cit</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">,</span>
                    <span class="n">ref_material</span><span class="o">.</span><span class="n">get_material_properties</span><span class="p">(),</span>
                    <span class="n">material_state</span><span class="o">.</span><span class="n">get_material_phases</span><span class="p">(),</span>
                    <span class="n">crve</span><span class="o">.</span><span class="n">get_phase_n_clusters</span><span class="p">(),</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_phase_clusters</span><span class="p">(),</span>
                    <span class="n">crve</span><span class="o">.</span><span class="n">get_cit_x_mf</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_cit_x_mf</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">crve</span><span class="o">.</span><span class="n">get_cit_x_mf</span><span class="p">()[</span><span class="mi">2</span><span class="p">])</span>
                <span class="c1">#</span>
                <span class="c1">#                                 Newton-Raphson iterative loop</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Initialize Newton-Raphson iteration counter</span>
                <span class="n">nr_iter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># Display Newton-Raphson iteration header</span>
                <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_display_nr_iter_data</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
                <span class="c1"># Set Newton-Raphson iteration initial time</span>
                <span class="n">nr_iter_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="c1"># -------------------------------------------------------------</span>
                <span class="c1"># Start Newton-Raphson iterative loop</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="c1">#</span>
                    <span class="c1">#                         Cluster material state update and</span>
                    <span class="c1">#                                consistent tangent modulus</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Get clusters incremental strain in matricial form</span>
                    <span class="n">clusters_inc_strain_mf</span> <span class="o">=</span> \
                        <span class="n">material_state</span><span class="o">.</span><span class="n">get_clusters_inc_strain_mf</span><span class="p">(</span>
                            <span class="n">global_strain_mf</span><span class="p">)</span>
                    <span class="c1"># Perform clusters material state update and compute</span>
                    <span class="c1"># associated consistent tangent modulus</span>
                    <span class="n">su_fail_state</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">update_clusters_state</span><span class="p">(</span>
                        <span class="n">clusters_inc_strain_mf</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Raise increment cut procedure if material cluster state</span>
                    <span class="c1"># update failed</span>
                    <span class="k">if</span> <span class="n">su_fail_state</span><span class="p">[</span><span class="s1">&#39;is_su_fail&#39;</span><span class="p">]:</span>
                        <span class="c1"># Set increment cut flag</span>
                        <span class="n">is_inc_cut</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="c1"># Display increment cut</span>
                        <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;11&#39;</span><span class="p">,</span> <span class="s1">&#39;su_fail&#39;</span><span class="p">,</span> <span class="n">su_fail_state</span><span class="p">)</span>
                        <span class="c1"># Leave Newton-Raphson equilibrium iterative loop</span>
                        <span class="k">break</span>
                    <span class="c1">#</span>
                    <span class="c1">#                     Homogenized strain and stress tensors</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Update homogenized strain and stress tensors</span>
                    <span class="n">material_state</span><span class="o">.</span><span class="n">update_state_homogenization</span><span class="p">()</span>
                    <span class="c1">#</span>
                    <span class="c1">#        Global cluster interaction - tangent moduli matrix</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Compute global cluster interaction - tangent moduli</span>
                    <span class="c1"># matrix</span>
                    <span class="n">global_cit_diff_tangent_mf</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">_build_global_cit_diff_tangent_mf</span><span class="p">(</span>
                            <span class="n">crve</span><span class="p">,</span> <span class="n">global_cit_mf</span><span class="p">,</span> <span class="n">material_state</span><span class="p">,</span> <span class="n">ref_material</span><span class="p">)</span>
                    <span class="c1">#</span>
                    <span class="c1">#                  Lippmann-Schwinger equilibrium residuals</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Build Lippmann-Schwinger equilibrium residuals</span>
                    <span class="n">residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_residual</span><span class="p">(</span>
                        <span class="n">crve</span><span class="p">,</span> <span class="n">material_state</span><span class="p">,</span>
                        <span class="n">presc_strain_idxs</span><span class="p">,</span> <span class="n">presc_stress_idxs</span><span class="p">,</span>
                        <span class="n">applied_mac_load_mf</span><span class="p">,</span> <span class="n">ref_material</span><span class="p">,</span> <span class="n">global_cit_mf</span><span class="p">,</span>
                        <span class="n">global_strain_mf</span><span class="p">,</span>
                        <span class="n">inc_mac_load_mf</span><span class="o">=</span><span class="n">inc_mac_load_mf</span><span class="p">,</span>
                        <span class="n">farfield_strain_mf</span><span class="o">=</span><span class="n">farfield_strain_mf</span><span class="p">,</span>
                        <span class="n">farfield_strain_old_mf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_farfield_strain_old_mf</span><span class="p">)</span>
                    <span class="c1">#</span>
                    <span class="c1">#                                    Convergence evaluation</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Evaluate Lippmann-Schwinger equilibrium solution</span>
                    <span class="c1"># convergence</span>
                    <span class="n">is_converged</span><span class="p">,</span> <span class="n">conv_errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_convergence</span><span class="p">(</span>
                        <span class="n">crve</span><span class="p">,</span> <span class="n">material_state</span><span class="p">,</span> <span class="n">presc_strain_idxs</span><span class="p">,</span>
                        <span class="n">presc_stress_idxs</span><span class="p">,</span> <span class="n">applied_mac_load_mf</span><span class="p">,</span> <span class="n">residual</span><span class="p">)</span>
                    <span class="c1"># Display Newton-Raphson iteration header</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_display_nr_iter_data</span><span class="p">(</span>
                        <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;iter&#39;</span><span class="p">,</span> <span class="n">nr_iter</span><span class="o">=</span><span class="n">nr_iter</span><span class="p">,</span>
                        <span class="n">nr_iter_time</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">nr_iter_init_time</span><span class="p">,</span>
                        <span class="n">errors</span><span class="o">=</span><span class="n">conv_errors</span><span class="p">)</span>
                    <span class="c1">#</span>
                    <span class="c1">#                             Newton-Raphson iterative flow</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Control Newton-Raphson iteration loop flow</span>
                    <span class="k">if</span> <span class="n">is_converged</span><span class="p">:</span>
                        <span class="c1"># Leave Newton-Raphson iterative loop (converged</span>
                        <span class="c1"># solution)</span>
                        <span class="k">break</span>
                    <span class="k">elif</span> <span class="n">nr_iter</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_n_iterations</span><span class="p">:</span>
                        <span class="c1"># Raise macroscale increment cut procedure</span>
                        <span class="n">is_inc_cut</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="c1"># Display increment cut</span>
                        <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;11&#39;</span><span class="p">,</span> <span class="s1">&#39;max_iter&#39;</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">_max_n_iterations</span><span class="p">)</span>
                        <span class="c1"># Leave Newton-Raphson equilibrium iterative loop</span>
                        <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Increment iteration counter</span>
                        <span class="n">nr_iter</span> <span class="o">=</span> <span class="n">nr_iter</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="c1"># Set Newton-Raphson iteration initial time</span>
                        <span class="n">nr_iter_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="c1">#</span>
                    <span class="c1">#            Lippmann-Schwinger equilibrium Jacobian matrix</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Build Lippmann-Schwinger equilibrium Jacobian matrix</span>
                    <span class="n">jacobian</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_jacobian</span><span class="p">(</span><span class="n">crve</span><span class="p">,</span> <span class="n">material_state</span><span class="p">,</span>
                                                    <span class="n">presc_strain_idxs</span><span class="p">,</span>
                                                    <span class="n">presc_stress_idxs</span><span class="p">,</span>
                                                    <span class="n">global_cit_diff_tangent_mf</span><span class="p">)</span>
                    <span class="c1">#</span>
                    <span class="c1">#                   Lippmann-Schwinger equilibrium solution</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Solve Lippmann-Schwinger equilibrium system of linearized</span>
                    <span class="c1"># equilibrium equations</span>
                    <span class="n">d_iter</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">jacobian</span><span class="p">,</span> <span class="o">-</span><span class="n">residual</span><span class="p">)</span>
                    <span class="c1">#</span>
                    <span class="c1">#                                  Strains iterative update</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Update clusters incremental strain</span>
                    <span class="n">global_strain_mf</span> <span class="o">=</span> <span class="n">global_strain_mf</span> <span class="o">+</span> \
                        <span class="n">d_iter</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">crve</span><span class="o">.</span><span class="n">get_n_total_clusters</span><span class="p">()</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)]</span>
                    <span class="c1"># Update far-field strain</span>
                    <span class="n">farfield_strain_mf</span> <span class="o">=</span> <span class="n">farfield_strain_mf</span> <span class="o">+</span> <span class="n">d_iter</span><span class="p">[</span>
                        <span class="n">crve</span><span class="o">.</span><span class="n">get_n_total_clusters</span><span class="p">()</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">):]</span>
                <span class="c1">#</span>
                <span class="c1">#                                        Self-consistent scheme</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># If raising a loading increment cut, leave self-consistent</span>
                <span class="c1"># iterative loop</span>
                <span class="k">if</span> <span class="n">is_inc_cut</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Compute CRVE effective tangent modulus and clusters strain</span>
                <span class="c1"># concentration tensors</span>
                <span class="n">eff_tangent_mf</span><span class="p">,</span> <span class="n">clusters_sct_mf</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_crve_effective_tangent_modulus</span><span class="p">(</span>
                        <span class="n">crve</span><span class="p">,</span> <span class="n">material_state</span><span class="p">,</span> <span class="n">global_cit_diff_tangent_mf</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Set post-processing procedure initial time</span>
                <span class="n">procedure_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="c1"># Output reference material associated quantities (.refm file)</span>
                <span class="k">if</span> <span class="n">is_ref_material_output</span><span class="p">:</span>
                    <span class="n">ref_mat_output</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span>
                        <span class="n">inc</span><span class="p">,</span> <span class="n">ref_material</span><span class="p">,</span>
                        <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_strain_mf</span><span class="p">(),</span>
                        <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_stress_mf</span><span class="p">(),</span>
                        <span class="n">farfield_strain_mf</span><span class="p">,</span> <span class="n">applied_mac_load_mf</span><span class="p">[</span><span class="s1">&#39;strain&#39;</span><span class="p">],</span>
                        <span class="n">eff_tangent_mf</span><span class="o">=</span><span class="n">eff_tangent_mf</span><span class="p">)</span>
                    <span class="c1"># Increment post-processing time</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_post_process_time</span> <span class="o">+=</span> \
                        <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">procedure_init_time</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Solve self-consistent minimization problem</span>
                <span class="k">if</span> <span class="n">is_lock_prop_ref</span><span class="p">:</span>
                    <span class="c1"># Skip update of reference material elastic properties</span>
                    <span class="n">E_ref</span> <span class="o">=</span> <span class="n">ref_material</span><span class="o">.</span><span class="n">get_material_properties</span><span class="p">()[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span>
                    <span class="n">v_ref</span> <span class="o">=</span> <span class="n">ref_material</span><span class="o">.</span><span class="n">get_material_properties</span><span class="p">()[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Compute reference material elastic properties through the</span>
                    <span class="c1"># solution of a self-consistent minimization problem</span>
                    <span class="n">is_scs_admissible</span><span class="p">,</span> <span class="n">E_ref</span><span class="p">,</span> <span class="n">v_ref</span> <span class="o">=</span> \
                        <span class="n">ref_material</span><span class="o">.</span><span class="n">self_consistent_update</span><span class="p">(</span>
                            <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_strain_mf</span><span class="p">(),</span>
                            <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_strain_old_mf</span><span class="p">(),</span>
                            <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_stress_mf</span><span class="p">(),</span>
                            <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_stress_old_mf</span><span class="p">(),</span>
                            <span class="n">eff_tangent_mf</span><span class="p">)</span>
                    <span class="c1"># If self-consistent scheme iterative solution is not</span>
                    <span class="c1"># admissible, either accept the current solution (first</span>
                    <span class="c1"># self-consistent scheme iteration) or perform one last</span>
                    <span class="c1"># self-consistent scheme iteration with the last converged</span>
                    <span class="c1"># increment reference material elastic properties</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scs_admissible</span><span class="p">:</span>
                        <span class="c1"># Display reference material self-consistent scheme</span>
                        <span class="c1"># iteration footer</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_display_scs_iter_data</span><span class="p">(</span>
                            <span class="n">ref_material</span><span class="p">,</span> <span class="n">is_lock_prop_ref</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;end&#39;</span><span class="p">,</span>
                            <span class="n">scs_iter_time</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">scs_iter_init_time</span><span class="p">)</span>
                        <span class="c1"># Elastic reference material properties locking</span>
                        <span class="k">if</span> <span class="n">ref_material</span><span class="o">.</span><span class="n">get_scs_iter</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># Display locking of reference material elastic</span>
                            <span class="c1"># properties</span>
                            <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;14&#39;</span><span class="p">,</span> <span class="s1">&#39;locked_scs_solution&#39;</span><span class="p">)</span>
                            <span class="c1"># Leave self-consistent scheme iterative loop</span>
                            <span class="c1"># (accepted solution)</span>
                            <span class="k">break</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Display locking of reference material elastic</span>
                            <span class="c1"># properties</span>
                            <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;14&#39;</span><span class="p">,</span> <span class="s1">&#39;inadmissible_scs_solution&#39;</span><span class="p">)</span>
                            <span class="c1"># If inadmissible self-consistent scheme solution,</span>
                            <span class="c1"># reset reference material elastic properties to</span>
                            <span class="c1"># the last converged increment values</span>
                            <span class="n">ref_material</span><span class="o">.</span><span class="n">reset_material_properties</span><span class="p">()</span>
                            <span class="c1"># Lock reference material elastic properties</span>
                            <span class="n">is_lock_prop_ref</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="c1"># Perform one last self-consistent scheme iteration</span>
                            <span class="c1"># with the last converged increment reference</span>
                            <span class="c1"># material elastic properties</span>
                            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_display_scs_iter_data</span><span class="p">(</span>
                                <span class="n">ref_material</span><span class="p">,</span> <span class="n">is_lock_prop_ref</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
                            <span class="c1"># Proceed to last self-consistent scheme iteration</span>
                            <span class="k">continue</span>
                <span class="c1">#</span>
                <span class="c1">#                                        Convergence evaluation</span>
                <span class="c1">#                                      (self-consistent scheme)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Check self-consistent scheme iterative solution convergence</span>
                <span class="n">is_scs_converged</span> <span class="o">=</span> \
                    <span class="n">ref_material</span><span class="o">.</span><span class="n">check_scs_convergence</span><span class="p">(</span><span class="n">E_ref</span><span class="p">,</span> <span class="n">v_ref</span><span class="p">)</span>
                <span class="c1"># Display reference material self-consistent scheme iteration</span>
                <span class="c1"># footer</span>
                <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_display_scs_iter_data</span><span class="p">(</span>
                    <span class="n">ref_material</span><span class="p">,</span> <span class="n">is_lock_prop_ref</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;end&#39;</span><span class="p">,</span>
                    <span class="n">scs_iter_time</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">scs_iter_init_time</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Self-consistent scheme iterative flow</span>
                <span class="k">if</span> <span class="n">is_scs_converged</span><span class="p">:</span>
                    <span class="c1"># Reset flag that locks reference material elastic</span>
                    <span class="c1"># properties</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_self_consistent_scheme</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                        <span class="n">is_lock_prop_ref</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="c1"># Leave self-consistent scheme iterative loop (converged</span>
                    <span class="c1"># solution)</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">ref_material</span><span class="o">.</span><span class="n">get_scs_iter</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scs_max_n_iterations</span><span class="p">:</span>
                    <span class="c1"># Display locking of reference material elastic properties</span>
                    <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;14&#39;</span><span class="p">,</span> <span class="s1">&#39;max_scs_iter&#39;</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_scs_max_n_iterations</span><span class="p">)</span>
                    <span class="c1"># If the maximum number of self-consistent scheme</span>
                    <span class="c1"># iterations is reached without convergence, reset elastic</span>
                    <span class="c1"># reference material properties to last loading increment</span>
                    <span class="c1"># values</span>
                    <span class="n">ref_material</span><span class="o">.</span><span class="n">reset_material_properties</span><span class="p">()</span>
                    <span class="c1"># Lock reference material elastic properties</span>
                    <span class="n">is_lock_prop_ref</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># Perform one last self-consistent scheme iteration with</span>
                    <span class="c1"># the last converged increment reference material elastic</span>
                    <span class="c1"># properties</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_display_scs_iter_data</span><span class="p">(</span>
                        <span class="n">ref_material</span><span class="p">,</span> <span class="n">is_lock_prop_ref</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Update reference material elastic properties</span>
                    <span class="n">ref_material</span><span class="o">.</span><span class="n">update_material_properties</span><span class="p">(</span><span class="n">E_ref</span><span class="p">,</span> <span class="n">v_ref</span><span class="p">)</span>
                    <span class="c1"># Increment self-consistent scheme iteration counter</span>
                    <span class="n">ref_material</span><span class="o">.</span><span class="n">update_scs_iter</span><span class="p">()</span>
                    <span class="c1"># Display reference material self-consistent scheme</span>
                    <span class="c1"># iteration data</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_display_scs_iter_data</span><span class="p">(</span>
                        <span class="n">ref_material</span><span class="p">,</span> <span class="n">is_lock_prop_ref</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
                    <span class="c1"># Set self-consistent scheme iteration initial time</span>
                    <span class="n">scs_iter_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="c1">#</span>
            <span class="c1">#                                             Loading increment cut</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="k">if</span> <span class="n">is_inc_cut</span><span class="p">:</span>
                <span class="c1"># Reset loading increment cut flag</span>
                <span class="n">is_inc_cut</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Reset elastic reference material properties to last loading</span>
                <span class="c1"># increment values</span>
                <span class="n">ref_material</span><span class="o">.</span><span class="n">reset_material_properties</span><span class="p">()</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Perform loading increment cut and setup new loading increment</span>
                <span class="n">applied_mac_load_mf</span><span class="p">,</span> <span class="n">inc_mac_load_mf</span><span class="p">,</span> <span class="n">n_presc_strain</span><span class="p">,</span> \
                    <span class="n">presc_strain_idxs</span><span class="p">,</span> <span class="n">n_presc_stress</span><span class="p">,</span> <span class="n">presc_stress_idxs</span><span class="p">,</span> \
                    <span class="n">is_last_inc</span> <span class="o">=</span> <span class="n">mac_load_path</span><span class="o">.</span><span class="n">increment_cut</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span>
                                                              <span class="n">comp_order</span><span class="p">)</span>
                <span class="c1"># Get increment counter</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="n">mac_load_path</span><span class="o">.</span><span class="n">get_increm_state</span><span class="p">()[</span><span class="s1">&#39;inc&#39;</span><span class="p">]</span>
                <span class="c1"># Display increment data</span>
                <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_display_inc_data</span><span class="p">(</span><span class="n">mac_load_path</span><span class="p">)</span>
                <span class="c1"># Set increment initial time</span>
                <span class="n">inc_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="c1"># Start new loading increment solution procedures</span>
                <span class="k">continue</span>
            <span class="c1">#</span>
            <span class="c1">#                                             Clustering adaptivity</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># This section should only be executed if the loading increment</span>
            <span class="c1"># where the clustering adaptivity condition is triggered is to be</span>
            <span class="c1"># repeated considering the new clustering</span>
            <span class="k">if</span> <span class="n">is_crve_adaptivity</span> <span class="ow">and</span> <span class="n">is_adapt_repeat_inc</span> \
                    <span class="ow">and</span> <span class="n">adaptivity_manager</span><span class="o">.</span><span class="n">check_inc_adaptive_steps</span><span class="p">(</span><span class="n">inc</span><span class="p">):</span>
                <span class="c1"># Display increment data</span>
                <span class="k">if</span> <span class="n">is_clust_adapt_output</span><span class="p">:</span>
                    <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;12&#39;</span><span class="p">,</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_adaptive_step</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># Build clusters equilibrium residuals</span>
                <span class="n">clusters_residuals_mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_clusters_residuals</span><span class="p">(</span>
                    <span class="n">material_state</span><span class="o">.</span><span class="n">get_material_phases</span><span class="p">(),</span>
                    <span class="n">crve</span><span class="o">.</span><span class="n">get_phase_clusters</span><span class="p">(),</span> <span class="n">residual</span><span class="p">)</span>
                <span class="c1"># Get clustering adaptivity trigger condition and target</span>
                <span class="c1"># clusters</span>
                <span class="n">is_trigger</span><span class="p">,</span> <span class="n">target_clusters</span><span class="p">,</span> <span class="n">target_clusters_data</span> <span class="o">=</span> \
                    <span class="n">adaptivity_manager</span><span class="o">.</span><span class="n">get_target_clusters</span><span class="p">(</span>
                        <span class="n">crve</span><span class="o">.</span><span class="n">get_phase_clusters</span><span class="p">(),</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_voxels_clusters</span><span class="p">(),</span>
                        <span class="n">material_state</span><span class="o">.</span><span class="n">get_clusters_def_gradient_mf</span><span class="p">(),</span>
                        <span class="n">material_state</span><span class="o">.</span><span class="n">get_clusters_def_gradient_old_mf</span><span class="p">(),</span>
                        <span class="n">material_state</span><span class="o">.</span><span class="n">get_clusters_state</span><span class="p">(),</span>
                        <span class="n">material_state</span><span class="o">.</span><span class="n">get_clusters_state_old</span><span class="p">(),</span>
                        <span class="n">clusters_sct_mf</span><span class="p">,</span> <span class="n">clusters_sct_old_mf</span><span class="p">,</span>
                        <span class="n">clusters_residuals_mf</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="n">is_clust_adapt_output</span><span class="p">)</span>
                <span class="c1"># Perform clustering adaptivity if adaptivity condition is</span>
                <span class="c1"># triggered</span>
                <span class="k">if</span> <span class="n">is_trigger</span><span class="p">:</span>
                    <span class="c1"># Display clustering adaptivity</span>
                    <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;16&#39;</span><span class="p">,</span> <span class="s1">&#39;repeat&#39;</span><span class="p">,</span> <span class="n">inc</span><span class="p">)</span>
                    <span class="c1"># Set improved initial iterative guess for the clusters</span>
                    <span class="c1"># strain global vector (matricial form) after the</span>
                    <span class="c1"># clustering adaptivity</span>
                    <span class="n">is_improved_init_guess</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">improved_init_guess</span> <span class="o">=</span> \
                        <span class="p">[</span><span class="n">is_improved_init_guess</span><span class="p">,</span> <span class="n">global_strain_mf</span><span class="p">]</span>
                    <span class="c1"># Perform clustering adaptivity</span>
                    <span class="n">adaptivity_manager</span><span class="o">.</span><span class="n">adaptive_refinement</span><span class="p">(</span>
                        <span class="n">crve</span><span class="p">,</span> <span class="n">material_state</span><span class="p">,</span> <span class="n">target_clusters</span><span class="p">,</span>
                        <span class="n">target_clusters_data</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span>
                        <span class="n">improved_init_guess</span><span class="o">=</span><span class="n">improved_init_guess</span><span class="p">,</span>
                        <span class="n">verbose</span><span class="o">=</span><span class="n">is_clust_adapt_output</span><span class="p">)</span>
                    <span class="c1"># Get improved initial iterative guess for the clusters</span>
                    <span class="c1"># strain global vector (matricial form)</span>
                    <span class="k">if</span> <span class="n">is_improved_init_guess</span><span class="p">:</span>
                        <span class="n">global_strain_mf</span> <span class="o">=</span> <span class="n">improved_init_guess</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Get increment counter</span>
                    <span class="n">inc</span> <span class="o">=</span> <span class="n">mac_load_path</span><span class="o">.</span><span class="n">get_increm_state</span><span class="p">()[</span><span class="s1">&#39;inc&#39;</span><span class="p">]</span>
                    <span class="c1"># Display increment data</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_display_inc_data</span><span class="p">(</span><span class="n">mac_load_path</span><span class="p">)</span>
                    <span class="c1"># Set increment initial time</span>
                    <span class="n">inc_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="c1"># Start new loading increment solution</span>
                    <span class="k">continue</span>
            <span class="c1">#</span>
            <span class="c1">#                                                Solution rewinding</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Check rewind operations availability</span>
            <span class="k">if</span> <span class="n">is_solution_rewinding</span> <span class="ow">and</span> <span class="n">is_inc_rewinder</span> \
                    <span class="ow">and</span> <span class="n">rewind_manager</span><span class="o">.</span><span class="n">is_rewind_available</span><span class="p">():</span>
                <span class="c1"># Check analysis rewind criteria</span>
                <span class="n">is_rewind</span> <span class="o">=</span> <span class="n">rewind_manager</span><span class="o">.</span><span class="n">is_rewinding_criteria</span><span class="p">(</span>
                    <span class="n">inc</span><span class="p">,</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_material_phases</span><span class="p">(),</span>
                    <span class="n">crve</span><span class="o">.</span><span class="n">get_phase_clusters</span><span class="p">(),</span>
                    <span class="n">material_state</span><span class="o">.</span><span class="n">get_clusters_state</span><span class="p">())</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Rewind analysis if criteria are met</span>
                <span class="k">if</span> <span class="n">is_rewind</span><span class="p">:</span>
                    <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;17&#39;</span><span class="p">,</span> <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">get_rewind_inc</span><span class="p">())</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Rewind loading path</span>
                    <span class="n">mac_load_path</span> <span class="o">=</span> <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">get_loading_path</span><span class="p">()</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Rewind material constitutive state</span>
                    <span class="n">material_state</span> <span class="o">=</span> <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">get_material_state</span><span class="p">(</span><span class="n">crve</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Rewind elastic reference material</span>
                    <span class="n">ref_material</span> <span class="o">=</span> <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">get_reference_material</span><span class="p">()</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Rewind clusters strain concentration tensors</span>
                    <span class="n">clusters_sct_old_mf</span> <span class="o">=</span> <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">get_clusters_sct</span><span class="p">()</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Rewind algorithmic variables</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_global_strain_old_mf</span><span class="p">,</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">_farfield_strain_old_mf</span> <span class="o">=</span> \
                        <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">get_asca_algorithmic_variables</span><span class="p">()</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Set post-processing procedure initial time</span>
                    <span class="n">procedure_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="c1"># Rewind output files</span>
                    <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">rewind_output_files</span><span class="p">(</span>
                        <span class="n">hres_output</span><span class="p">,</span> <span class="n">efftan_output</span><span class="p">,</span> <span class="n">ref_mat_output</span><span class="p">,</span>
                        <span class="n">voxels_output</span><span class="p">,</span> <span class="n">adapt_output</span><span class="p">,</span> <span class="n">vtk_output</span><span class="p">)</span>
                    <span class="c1"># Increment post-processing time</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_post_process_time</span> <span class="o">+=</span> \
                        <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">procedure_init_time</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Reset clustering adaptive steps</span>
                    <span class="k">if</span> <span class="n">is_crve_adaptivity</span><span class="p">:</span>
                        <span class="n">adaptivity_manager</span><span class="o">.</span><span class="n">clear_inc_adaptive_steps</span><span class="p">(</span>
                            <span class="n">inc_threshold</span><span class="o">=</span><span class="n">inc_rewinder</span><span class="o">.</span><span class="n">get_rewind_inc</span><span class="p">())</span>
                    <span class="c1"># Update total rewind time</span>
                    <span class="n">rewind_manager</span><span class="o">.</span><span class="n">update_rewind_time</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;update&#39;</span><span class="p">)</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Setup new loading increment</span>
                    <span class="n">applied_mac_load_mf</span><span class="p">,</span> <span class="n">inc_mac_load_mf</span><span class="p">,</span> <span class="n">n_presc_strain</span><span class="p">,</span> \
                        <span class="n">presc_strain_idxs</span><span class="p">,</span> <span class="n">n_presc_stress</span><span class="p">,</span> <span class="n">presc_stress_idxs</span><span class="p">,</span> \
                        <span class="n">is_last_inc</span> <span class="o">=</span> <span class="n">mac_load_path</span><span class="o">.</span><span class="n">new_load_increment</span><span class="p">()</span>
                    <span class="c1"># Get increment counter</span>
                    <span class="n">inc</span> <span class="o">=</span> <span class="n">mac_load_path</span><span class="o">.</span><span class="n">get_increm_state</span><span class="p">()[</span><span class="s1">&#39;inc&#39;</span><span class="p">]</span>
                    <span class="c1"># Display increment data</span>
                    <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_display_inc_data</span><span class="p">(</span><span class="n">mac_load_path</span><span class="p">)</span>
                    <span class="c1"># Set increment initial time</span>
                    <span class="n">inc_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                    <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                    <span class="c1"># Start new loading increment solution</span>
                    <span class="k">continue</span>
            <span class="c1">#</span>
            <span class="c1">#                             Homogenized strain and stress tensors</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Get homogenized strain and stress tensors (matricial form)</span>
            <span class="n">hom_strain_mf</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_strain_mf</span><span class="p">()</span>
            <span class="n">hom_stress_mf</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_stress_mf</span><span class="p">()</span>
            <span class="c1"># Build homogenized strain and stress tensors</span>
            <span class="n">hom_strain</span> <span class="o">=</span> <span class="n">mop</span><span class="o">.</span><span class="n">get_tensor_from_mf</span><span class="p">(</span><span class="n">hom_strain_mf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span>
                                                <span class="n">comp_order</span><span class="p">)</span>
            <span class="n">hom_stress</span> <span class="o">=</span> <span class="n">mop</span><span class="o">.</span><span class="n">get_tensor_from_mf</span><span class="p">(</span><span class="n">hom_stress_mf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span>
                                                <span class="n">comp_order</span><span class="p">)</span>
            <span class="c1"># Get homogenized strain or stress tensor out-of-plane component</span>
            <span class="c1"># (output only)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">hom_stress_33</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_oop_hom_comp</span><span class="p">()</span>
            <span class="c1">#</span>
            <span class="c1">#                        Increment homogenized results (.hres file)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Initialize homogenized results dictionary</span>
            <span class="n">hom_results</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="c1"># Build homogenized results dictionary</span>
            <span class="n">hom_results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;hom_strain&#39;</span><span class="p">:</span> <span class="n">hom_strain</span><span class="p">,</span> <span class="s1">&#39;hom_stress&#39;</span><span class="p">:</span> <span class="n">hom_stress</span><span class="p">}</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">hom_results</span><span class="p">[</span><span class="s1">&#39;hom_stress_33&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hom_stress_33</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set post-processing procedure initial time</span>
            <span class="n">procedure_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="c1"># Write increment homogenized results (.hres)</span>
            <span class="n">hres_output</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">,</span> <span class="n">mac_load_path</span><span class="p">,</span>
                <span class="n">hom_results</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">init_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_process_time</span><span class="p">)</span>
            <span class="c1"># Write increment CRVE effective tangent modulus (.efftan)</span>
            <span class="n">efftan_output</span><span class="o">.</span><span class="n">write_file</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">,</span> <span class="n">mac_load_path</span><span class="p">,</span>
                <span class="n">eff_tangent_mf</span><span class="p">)</span>
            <span class="c1"># Increment post-processing time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_post_process_time</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">procedure_init_time</span>
            <span class="c1">#</span>
            <span class="c1">#                                                Increment VTK file</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Write VTK file associated with the loading increment</span>
            <span class="k">if</span> <span class="n">is_vtk_output</span> <span class="ow">and</span> <span class="n">inc</span> <span class="o">%</span> <span class="n">vtk_inc_div</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Set post-processing procedure initial time</span>
                <span class="n">procedure_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="c1"># Write VTK file associated with the converged increment</span>
                <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;18&#39;</span><span class="p">)</span>
                <span class="n">vtk_output</span><span class="o">.</span><span class="n">write_vtk_file_time_step</span><span class="p">(</span>
                    <span class="n">inc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">,</span> <span class="n">crve</span><span class="p">,</span>
                    <span class="n">material_state</span><span class="p">,</span> <span class="n">vtk_vars</span><span class="o">=</span><span class="n">vtk_data</span><span class="p">[</span><span class="s1">&#39;vtk_vars&#39;</span><span class="p">],</span>
                    <span class="n">adaptivity_manager</span><span class="o">=</span><span class="n">adaptivity_manager</span><span class="p">)</span>
                <span class="c1"># Increment post-processing time</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_post_process_time</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">procedure_init_time</span>
            <span class="c1">#</span>
            <span class="c1">#                                Converged material state variables</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Update last converged material state variables</span>
            <span class="n">material_state</span><span class="o">.</span><span class="n">update_converged_state</span><span class="p">()</span>
            <span class="c1"># Update last converged clusters strain concentration tensors</span>
            <span class="n">clusters_sct_old_mf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">clusters_sct_mf</span><span class="p">)</span>
            <span class="c1">#</span>
            <span class="c1">#           Converged elastic reference material elastic properties</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Set reference material properties converged in the first loading</span>
            <span class="c1"># increment</span>
            <span class="k">if</span> <span class="n">inc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ref_material</span><span class="o">.</span><span class="n">set_material_properties_scs_init</span><span class="p">()</span>
            <span class="c1"># Update converged elastic reference material elastic properties</span>
            <span class="n">ref_material</span><span class="o">.</span><span class="n">update_converged_material_properties</span><span class="p">()</span>
            <span class="c1">#</span>
            <span class="c1">#                                   Converged algorithmic variables</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Update last converged global vector of clusters strain tensors</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_global_strain_old_mf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">global_strain_mf</span><span class="p">)</span>
            <span class="c1"># Update last converged far-field strain tensor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_farfield_strain_old_mf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">farfield_strain_mf</span><span class="p">)</span>
            <span class="c1">#</span>
            <span class="c1">#                        Clustering adaptivity output (.adapt file)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Update clustering adaptivity output file with converged increment</span>
            <span class="c1"># data</span>
            <span class="k">if</span> <span class="n">is_crve_adaptivity</span><span class="p">:</span>
                <span class="c1"># Set post-processing procedure initial time</span>
                <span class="n">procedure_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="c1"># Update clustering adaptivity output file</span>
                <span class="n">adapt_output</span><span class="o">.</span><span class="n">write_adapt_file</span><span class="p">(</span><span class="n">inc</span><span class="p">,</span> <span class="n">adaptivity_manager</span><span class="p">,</span> <span class="n">crve</span><span class="p">,</span>
                                              <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;increment&#39;</span><span class="p">)</span>
                <span class="c1"># Increment post-processing time</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_post_process_time</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">procedure_init_time</span>
            <span class="c1">#</span>
            <span class="c1">#       Voxels cluster state based quantities output (.voxout file)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Update clustering adaptivity output file with converged increment</span>
            <span class="c1"># data</span>
            <span class="k">if</span> <span class="n">is_voxels_output</span><span class="p">:</span>
                <span class="c1"># Set post-processing procedure initial time</span>
                <span class="n">procedure_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="c1"># Update clustering adaptivity output file</span>
                <span class="n">voxels_output</span><span class="o">.</span><span class="n">write_voxels_output_file</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">,</span> <span class="n">crve</span><span class="p">,</span>
                    <span class="n">material_state</span><span class="o">.</span><span class="n">get_clusters_state</span><span class="p">())</span>
                <span class="c1"># Increment post-processing time</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_post_process_time</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">procedure_init_time</span>
            <span class="c1">#</span>
            <span class="c1">#                               Incremental macroscale loading flow</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Update converged macroscale (homogenized) state</span>
            <span class="n">mac_load_path</span><span class="o">.</span><span class="n">update_hom_state</span><span class="p">(</span><span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_strain_mf</span><span class="p">(),</span>
                                           <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_stress_mf</span><span class="p">())</span>
            <span class="c1"># Display converged increment data</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span>
                    <span class="s1">&#39;7&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">,</span>
                    <span class="n">hom_strain</span><span class="p">,</span> <span class="n">hom_stress</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">inc_init_time</span><span class="p">,</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">init_time</span><span class="p">,</span> <span class="n">hom_stress_33</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span>
                    <span class="s1">&#39;7&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">,</span>
                    <span class="n">hom_strain</span><span class="p">,</span> <span class="n">hom_stress</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">inc_init_time</span><span class="p">,</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">init_time</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Save macroscale loading increment (converged) state</span>
            <span class="k">if</span> <span class="n">is_solution_rewinding</span> <span class="ow">and</span> <span class="n">rewind_manager</span><span class="o">.</span><span class="n">is_rewind_available</span><span class="p">()</span> \
                    <span class="ow">and</span> <span class="n">rewind_manager</span><span class="o">.</span><span class="n">is_save_rewind_state</span><span class="p">(</span><span class="n">inc</span><span class="p">):</span>
                <span class="c1"># Set reference rewind time</span>
                <span class="n">rewind_manager</span><span class="o">.</span><span class="n">update_rewind_time</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;init&#39;</span><span class="p">)</span>
                <span class="c1"># Instantiate increment rewinder</span>
                <span class="n">inc_rewinder</span> <span class="o">=</span> <span class="n">IncrementRewinder</span><span class="p">(</span>
                    <span class="n">rewind_inc</span><span class="o">=</span><span class="n">inc</span><span class="p">,</span> <span class="n">phase_clusters</span><span class="o">=</span><span class="n">crve</span><span class="o">.</span><span class="n">get_phase_clusters</span><span class="p">())</span>
                <span class="c1"># Save loading path state</span>
                <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">save_loading_path</span><span class="p">(</span><span class="n">loading_path</span><span class="o">=</span><span class="n">mac_load_path</span><span class="p">)</span>
                <span class="c1"># Save material constitutive state</span>
                <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">save_material_state</span><span class="p">(</span><span class="n">material_state</span><span class="p">)</span>
                <span class="c1"># Save elastic reference material</span>
                <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">save_reference_material</span><span class="p">(</span><span class="n">ref_material</span><span class="p">)</span>
                <span class="c1"># Save clusters strain concentration tensors</span>
                <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">save_clusters_sct</span><span class="p">(</span><span class="n">clusters_sct_mf</span><span class="p">)</span>
                <span class="c1"># Save algorithmic variables</span>
                <span class="n">inc_rewinder</span><span class="o">.</span><span class="n">save_asca_algorithmic_variables</span><span class="p">(</span>
                    <span class="n">global_strain_mf</span><span class="p">,</span> <span class="n">farfield_strain_mf</span><span class="o">=</span><span class="n">farfield_strain_mf</span><span class="p">)</span>
                <span class="c1"># Set increment rewinder flag</span>
                <span class="n">is_inc_rewinder</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Return if last loading increment, otherwise setup new loading</span>
            <span class="c1"># increment</span>
            <span class="k">if</span> <span class="n">is_last_inc</span><span class="p">:</span>
                <span class="c1"># Set total time associated with online-stage</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_total_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">init_time</span>
                <span class="c1"># Set total time associated with the solution of the</span>
                <span class="c1"># equilibrium problem</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_effective_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_total_time</span> \
                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_post_process_time</span>
                <span class="c1"># Output clustering adaptivity summary</span>
                <span class="k">if</span> <span class="n">is_crve_adaptivity</span><span class="p">:</span>
                    <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;15&#39;</span><span class="p">,</span> <span class="n">adaptivity_manager</span><span class="p">,</span> <span class="n">crve</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_effective_time</span><span class="p">)</span>
                <span class="c1"># Finish solution of clustering-based reduced order equilibrium</span>
                <span class="c1"># problem</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Setup new loading increment</span>
                <span class="n">applied_mac_load_mf</span><span class="p">,</span> <span class="n">inc_mac_load_mf</span><span class="p">,</span> <span class="n">n_presc_strain</span><span class="p">,</span> \
                    <span class="n">presc_strain_idxs</span><span class="p">,</span> <span class="n">n_presc_stress</span><span class="p">,</span> <span class="n">presc_stress_idxs</span><span class="p">,</span> \
                    <span class="n">is_last_inc</span> <span class="o">=</span> <span class="n">mac_load_path</span><span class="o">.</span><span class="n">new_load_increment</span><span class="p">()</span>
                <span class="c1"># Get increment counter</span>
                <span class="n">inc</span> <span class="o">=</span> <span class="n">mac_load_path</span><span class="o">.</span><span class="n">get_increm_state</span><span class="p">()[</span><span class="s1">&#39;inc&#39;</span><span class="p">]</span>
                <span class="c1"># Display increment data</span>
                <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_display_inc_data</span><span class="p">(</span><span class="n">mac_load_path</span><span class="p">)</span>
                <span class="c1"># Set increment initial time</span>
                <span class="n">inc_init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._init_global_strain_mf"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._init_global_strain_mf">[docs]</a>    <span class="k">def</span> <span class="nf">_init_global_strain_mf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;last_converged&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set clusters strains initial iterative guess.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : {&#39;last_converged&#39;,}, default=&#39;last_converged&#39;</span>
<span class="sd">            Strategy to set clusters incremental strains initial iterative</span>
<span class="sd">            guess.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        global_strain_mf : numpy.ndarray (1d)</span>
<span class="sd">            Global vector of clusters strains stored in matricial form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;last_converged&#39;</span><span class="p">:</span>
            <span class="c1"># Set initial iterative guess associated with the last converged</span>
            <span class="c1"># solution</span>
            <span class="n">global_strain_mf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_global_strain_old_mf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unavailable strategy to set clusters strains &#39;</span>
                               <span class="s1">&#39;initial iterative guess.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">global_strain_mf</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._init_global_inc_strain_mf"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._init_global_inc_strain_mf">[docs]</a>    <span class="k">def</span> <span class="nf">_init_global_inc_strain_mf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_total_clusters</span><span class="p">,</span>
                                   <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;last_converged&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set clusters incremental strains initial iterative guess.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_total_clusters : int</span>
<span class="sd">            Total number of clusters.</span>
<span class="sd">        mode : {&#39;last_converged&#39;,}, default=&#39;last_converged&#39;</span>
<span class="sd">            Strategy to set clusters incremental strains initial iterative</span>
<span class="sd">            guess.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        global_inc_strain_mf : numpy.ndarray (1d)</span>
<span class="sd">            Global vector of clusters incremental strains stored in matricial</span>
<span class="sd">            form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;last_converged&#39;</span><span class="p">:</span>
            <span class="c1"># Set incremental initial iterative guess associated with the last</span>
            <span class="c1"># converged solution</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
                <span class="c1"># Set clusters infinitesimal strain tensors</span>
                <span class="n">global_inc_strain_mf</span> <span class="o">=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Set initialized deformation gradient (matricial form)</span>
                <span class="n">def_gradient_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="mf">0.0</span>
                                            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span><span class="p">])</span>
                <span class="c1"># Build clusters deformation gradients</span>
                <span class="n">global_inc_strain_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">def_gradient_mf</span><span class="p">,</span>
                                               <span class="n">n_total_clusters</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unavailable strategy to set clusters &#39;</span>
                               <span class="s1">&#39;incremental strains initial iterative guess.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">global_inc_strain_mf</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._init_farfield_strain_mf"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._init_farfield_strain_mf">[docs]</a>    <span class="k">def</span> <span class="nf">_init_farfield_strain_mf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;last_converged&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set far-field strain initial iterative guess.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : {&#39;last_converged&#39;,}, default=&#39;last_converged&#39;</span>
<span class="sd">            Strategy to set incremental far-field strain initial iterative</span>
<span class="sd">            guess.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        farfield_strain_mf : 1darray, default=None</span>
<span class="sd">            Incremental far-field strain tensor (matricial form).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;last_converged&#39;</span><span class="p">:</span>
            <span class="c1"># Set initial iterative guess associated with the last converged</span>
            <span class="c1"># solution</span>
            <span class="n">farfield_strain_mf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_farfield_strain_old_mf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unavailable strategy to set far-field strain &#39;</span>
                               <span class="s1">&#39;initial iterative guess.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">farfield_strain_mf</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._init_inc_farfield_strain_mf"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._init_inc_farfield_strain_mf">[docs]</a>    <span class="k">def</span> <span class="nf">_init_inc_farfield_strain_mf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;last_converged&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set incremental far-field strain initial iterative guess.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : {&#39;last_converged&#39;,}, default=&#39;last_converged&#39;</span>
<span class="sd">            Strategy to set incremental far-field strain initial iterative</span>
<span class="sd">            guess.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inc_farfield_strain_mf : numpy.ndarray (1d), default=None</span>
<span class="sd">            Incremental far-field strain tensor (matricial form).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;last_converged&#39;</span><span class="p">:</span>
            <span class="c1"># Set incremental initial iterative guess associated with the last</span>
            <span class="c1"># converged solution</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
                <span class="c1"># Set far-field infinitesimal strain tensor</span>
                <span class="n">inc_farfield_strain_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Set far-field deformation gradient</span>
                <span class="n">inc_farfield_strain_mf</span> <span class="o">=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="mf">0.0</span>
                              <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unavailable strategy to set incremental &#39;</span>
                               <span class="s1">&#39;far-field strain initial iterative guess.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">inc_farfield_strain_mf</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._build_residual"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._build_residual">[docs]</a>    <span class="k">def</span> <span class="nf">_build_residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crve</span><span class="p">,</span> <span class="n">material_state</span><span class="p">,</span> <span class="n">presc_strain_idxs</span><span class="p">,</span>
                        <span class="n">presc_stress_idxs</span><span class="p">,</span> <span class="n">applied_mac_load_mf</span><span class="p">,</span> <span class="n">ref_material</span><span class="p">,</span>
                        <span class="n">global_cit_mf</span><span class="p">,</span> <span class="n">global_strain_mf</span><span class="p">,</span> <span class="n">inc_mac_load_mf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">farfield_strain_mf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">farfield_strain_old_mf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build Lippmann-Schwinger equilibrium residuals.</span>

<span class="sd">        **Global residual function:**</span>

<span class="sd">            .. math::</span>

<span class="sd">               \\boldsymbol{R}_{n+1} =</span>
<span class="sd">               \\begin{bmatrix}</span>
<span class="sd">               \\boldsymbol{R}^{(I)}_{n+1} \\\\[5pt]</span>
<span class="sd">               \\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}</span>
<span class="sd">               \\end{bmatrix} =</span>
<span class="sd">               \\begin{bmatrix} \\boldsymbol{0} \\\\[5pt]</span>
<span class="sd">               \\boldsymbol{0}  \\end{bmatrix} \\, , \\qquad</span>
<span class="sd">               \\forall I = 1,2, \\, \\dots, \\, n_{\\text{c}} \\, ,</span>

<span class="sd">            where :math:`\\boldsymbol{R}_{n+1}` is the global residual</span>
<span class="sd">            function, :math:`\\boldsymbol{R}^{(I)}_{n+1}` is the :math:`I` th</span>
<span class="sd">            material cluster equilibrium residual function,</span>
<span class="sd">            :math:`\\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}` is the strain</span>
<span class="sd">            and/or stress loading constraints residual function,</span>
<span class="sd">            :math:`n_{c}` is the number of material clusters,</span>
<span class="sd">            and :math:`n+1` denotes the current increment.</span>

<span class="sd">        ----</span>

<span class="sd">        **Infinitesimal strains (incremental equilibrium formulation, \</span>
<span class="sd">                                 incremental primary unknowns):**</span>

<span class="sd">            *Equilibrium residuals*</span>

<span class="sd">                .. math::</span>

<span class="sd">                   \\boldsymbol{R}^{(I)}_{n+1} =</span>
<span class="sd">                   \\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(I)}</span>
<span class="sd">                   + \\sum^{n_{\\text{c}}}_{J=1}</span>
<span class="sd">                   \\boldsymbol{\\mathsf{T}}^{(I)(J)} : \\left(</span>
<span class="sd">                   \\Delta \\hat{\\boldsymbol{\\sigma}}_{\\mu,\\,n+1}^{(J)}</span>
<span class="sd">                   - \\boldsymbol{\\mathsf{D}}^{e,\\, 0}:</span>
<span class="sd">                   \\Delta\\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(J)}</span>
<span class="sd">                   \\right)</span>
<span class="sd">                   - \\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{0}\\, ,</span>

<span class="sd">                .. math::</span>

<span class="sd">                   \\forall I = 1, \\, \\dots, \\, n_{\\text{c}} \\, ,</span>

<span class="sd">                where :math:`\\boldsymbol{R}^{(I)}_{n+1}` is the :math:`I` th</span>
<span class="sd">                material cluster equilibrium residual function,</span>
<span class="sd">                :math:`\\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(I)}`</span>
<span class="sd">                is the :math:`I` th material cluster incremental infinitesimal</span>
<span class="sd">                strain tensor, :math:`\\boldsymbol{\\mathsf{T}}^{(I)(J)}` is</span>
<span class="sd">                the cluster interaction tensor (fourth-order tensor) between</span>
<span class="sd">                the :math:`I` th and :math:`J` th material clusters,</span>
<span class="sd">                :math:`\\Delta \\boldsymbol{\\sigma}_{\\mu,\\,n+1}^{(J)}` is</span>
<span class="sd">                the :math:`J` th material cluster incremental Cauchy stress</span>
<span class="sd">                tensor (:math:`\\hat{(\\cdot)}` denotes the incremental nature</span>
<span class="sd">                of the constitutive function),</span>
<span class="sd">                :math:`\\boldsymbol{\\mathsf{D}}^{e,\\, 0}` is the elastic</span>
<span class="sd">                tangent modulus of the reference homogeneous material,</span>
<span class="sd">                :math:`\\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{0}` is</span>
<span class="sd">                the incremental far-field infinitesimal strain tensor,</span>
<span class="sd">                :math:`n_{c}` is the number of material clusters, and</span>
<span class="sd">                :math:`n+1` denotes the current increment.</span>


<span class="sd">            *Loading (homogenization-based) strain and/or stress constraints*</span>

<span class="sd">                .. math::</span>

<span class="sd">                   \\boldsymbol{R}^{(n_{\\text{c}} + 1)}_{n+1} =</span>
<span class="sd">                   \\sum^{n_{\\text{c}}}_{I=1} f^{(I)}</span>
<span class="sd">                   \\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(I)}</span>
<span class="sd">                   - \\Delta \\boldsymbol{\\varepsilon}_{n+1} \\, ,</span>

<span class="sd">                where :math:`\\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}` is the</span>
<span class="sd">                strain loading constraint residual function, :math:`f^{(I)}` is</span>
<span class="sd">                the volume fraction of the :math:`I` th material cluster,</span>
<span class="sd">                :math:`\\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(I)}`</span>
<span class="sd">                is the :math:`I` th material cluster incremental infinitesimal</span>
<span class="sd">                strain tensor, :math:`\\Delta \\boldsymbol{\\varepsilon}_{n+1}`</span>
<span class="sd">                is the macroscale incremental Cauchy stress tensor,</span>
<span class="sd">                :math:`n_{c}` is the number of material clusters, and</span>
<span class="sd">                :math:`n+1` denotes the current increment.</span>

<span class="sd">                .. math::</span>

<span class="sd">                    \\boldsymbol{R}^{(n_{\\text{c}} + 1)}_{n+1} =</span>
<span class="sd">                    \\sum^{n_{\\text{c}}}_{I=1} f^{(I)}</span>
<span class="sd">                    \\Delta \\hat{\\boldsymbol{\\sigma}}_{\\mu,\\,n+1}^{(I)}</span>
<span class="sd">                    - \\Delta \\boldsymbol{\\sigma}_{n+1} \\, ,</span>

<span class="sd">                where :math:`\\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}` is the</span>
<span class="sd">                stress loading constraint residual function,</span>
<span class="sd">                :math:`f^{(I)}` is the volume fraction of the :math:`I` th</span>
<span class="sd">                material cluster,</span>
<span class="sd">                :math:`\\Delta \\boldsymbol{\\sigma}_{\\mu,\\,n+1}^{(I)}` is</span>
<span class="sd">                the :math:`I` th material cluster incremental Cauchy stress</span>
<span class="sd">                tensor (:math:`\\hat{(\\cdot)}` denotes the incremental nature</span>
<span class="sd">                of the constitutive function),</span>
<span class="sd">                :math:`\\Delta \\boldsymbol{\\sigma}_{n+1}` is the macroscale</span>
<span class="sd">                incremental Cauchy stress tensor, :math:`n_{c}` is the number</span>
<span class="sd">                of material clusters, and :math:`n+1` denotes the current</span>
<span class="sd">                increment.</span>

<span class="sd">        ----</span>

<span class="sd">        **Infinitesimal strains (incremental equilibrium formulation, \</span>
<span class="sd">                                 total primary unknowns):**</span>

<span class="sd">            This formulation is mathematically equivalent to the incremental</span>
<span class="sd">            formulation of the equilibrium problem. Based on the additive</span>
<span class="sd">            nature of both infinitesimal strain and Cauchy stress tensors, this</span>
<span class="sd">            functional format is suitable for a computational implementation</span>
<span class="sd">            where total primary unknowns are adopted.</span>

<span class="sd">            *Equilibrium residuals*</span>

<span class="sd">                .. math::</span>

<span class="sd">                   \\begin{multline}</span>
<span class="sd">                        \\boldsymbol{R}^{(I)}_{n+1} =</span>
<span class="sd">                        \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(I)}</span>
<span class="sd">                        + \\sum^{n_{\\text{c}}}_{J=1}</span>
<span class="sd">                        \\boldsymbol{\\mathsf{T}}^{(I)(J)} : \\left(</span>
<span class="sd">                        \\hat{\\boldsymbol{\\sigma}}_{\\mu,\\,n+1}^{(J)}</span>
<span class="sd">                        - \\boldsymbol{\\mathsf{D}}^{e,\\, 0}:</span>
<span class="sd">                        \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(J)} \\right)</span>
<span class="sd">                        -  \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{0} \\\\</span>
<span class="sd">                        - \\left( \\boldsymbol{\\varepsilon}_{\\mu,\\,n}^{(I)}</span>
<span class="sd">                        + \\sum^{n_{\\text{c}}}_{J=1}</span>
<span class="sd">                        \\boldsymbol{\\mathsf{T}}^{(I)(J)} : \\left(</span>
<span class="sd">                        \\boldsymbol{\\sigma}_{\\mu,\\,n}^{(J)}</span>
<span class="sd">                        - \\boldsymbol{\\mathsf{D}}^{e,\\, 0}:</span>
<span class="sd">                        \\boldsymbol{\\varepsilon}_{\\mu,\\,n}^{(J)} \\right)</span>
<span class="sd">                        - \\boldsymbol{\\varepsilon}_{\\mu,\\,n}^{0} \\right)</span>
<span class="sd">                        \\, ,</span>
<span class="sd">                    \\end{multline}</span>

<span class="sd">                .. math::</span>

<span class="sd">                   \\forall I = 1, \\, \\dots, \\, n_{\\text{c}} \\, ,</span>

<span class="sd">                where :math:`\\boldsymbol{R}^{(I)}_{n+1}` is the :math:`I` th</span>
<span class="sd">                material cluster equilibrium residual function,</span>
<span class="sd">                :math:`\\boldsymbol{\\varepsilon}_{\\mu}^{(I)}` is the</span>
<span class="sd">                :math:`I` th material cluster infinitesimal strain tensor,</span>
<span class="sd">                :math:`\\boldsymbol{\\mathsf{T}}^{(I)(J)}` is the cluster</span>
<span class="sd">                interaction tensor (fourth-order tensor) between the</span>
<span class="sd">                :math:`I` th and :math:`J` th material clusters,</span>
<span class="sd">                :math:`\\boldsymbol{\\sigma}_{\\mu}^{(J)}` is the :math:`J` th</span>
<span class="sd">                material cluster Cauchy stress tensor (:math:`\\hat{(\\cdot)}`</span>
<span class="sd">                denotes the incremental nature of the constitutive function),</span>
<span class="sd">                :math:`\\boldsymbol{\\mathsf{D}}^{e,\\, 0}` is the elastic</span>
<span class="sd">                tangent modulus of the reference homogeneous material,</span>
<span class="sd">                :math:`\\boldsymbol{\\varepsilon}_{\\mu}^{0}` is the far-field</span>
<span class="sd">                infinitesimal strain tensor, :math:`n_{c}` is the number of</span>
<span class="sd">                material clusters, :math:`n+1` denotes the current increment,</span>
<span class="sd">                and :math:`n` denotes the last converged increment.</span>


<span class="sd">            *Loading (homogenization-based) strain and/or stress constraints*</span>

<span class="sd">                .. math::</span>

<span class="sd">                   \\boldsymbol{R}^{(n_{\\text{c}} + 1)}_{n+1} =</span>
<span class="sd">                   \\sum^{n_{\\text{c}}}_{I=1} f^{(I)}</span>
<span class="sd">                   \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(I)}</span>
<span class="sd">                   - \\boldsymbol{\\varepsilon}_{n+1}</span>
<span class="sd">                   - \\left( \\sum^{n_{\\text{c}}}_{I=1} f^{(I)}</span>
<span class="sd">                   \\boldsymbol{\\varepsilon}_{\\mu,\\,n}^{(I)}</span>
<span class="sd">                   - \\boldsymbol{\\varepsilon}_{n}  \\right) \\, ,</span>

<span class="sd">                where :math:`\\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}` is the</span>
<span class="sd">                strain loading constraint residual function, :math:`f^{(I)}` is</span>
<span class="sd">                the volume fraction of the :math:`I` th material cluster,</span>
<span class="sd">                :math:`\\boldsymbol{\\varepsilon}_{\\mu}^{(I)}` is the</span>
<span class="sd">                :math:`I` th material cluster infinitesimal strain tensor,</span>
<span class="sd">                :math:`\\boldsymbol{\\varepsilon}` is the macroscale</span>
<span class="sd">                infinitesimal strain tensor, :math:`n_{c}` is the number of</span>
<span class="sd">                material clusters, :math:`n+1` denotes the current increment,</span>
<span class="sd">                and :math:`n` denotes the last converged increment.</span>

<span class="sd">                .. math::</span>

<span class="sd">                    \\boldsymbol{R}^{(n_{\\text{c}} + 1)}_{n+1} =</span>
<span class="sd">                    \\sum^{n_{\\text{c}}}_{I=1} f^{(I)}</span>
<span class="sd">                    \\hat{\\boldsymbol{\\sigma}}_{\\mu,\\,n+1}^{(I)}</span>
<span class="sd">                    - \\boldsymbol{\\sigma}_{n+1} - \\left(</span>
<span class="sd">                    \\sum^{n_{\\text{c}}}_{I=1} f^{(I)}</span>
<span class="sd">                    \\boldsymbol{\\sigma}_{\\mu,\\,n}^{(I)}</span>
<span class="sd">                    - \\boldsymbol{\\sigma}_{n}  \\right) \\, ,</span>

<span class="sd">                where :math:`\\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}` is the</span>
<span class="sd">                stress loading constraint residual function,</span>
<span class="sd">                :math:`f^{(I)}` is the volume fraction of the :math:`I` th</span>
<span class="sd">                material cluster, :math:`\\boldsymbol{\\sigma}_{\\mu}^{(I)}` is</span>
<span class="sd">                the :math:`I` th material cluster Cauchy stress tensor</span>
<span class="sd">                (:math:`\\hat{(\\cdot)}` denotes the incremental nature of the</span>
<span class="sd">                constitutive function), :math:`\\boldsymbol{\\sigma}` is the</span>
<span class="sd">                macroscale incremental Cauchy stress tensor, :math:`n_{c}` is</span>
<span class="sd">                the number of material clusters, :math:`n+1` denotes the</span>
<span class="sd">                current increment, and :math:`n` denotes the last converged</span>
<span class="sd">                increment.</span>

<span class="sd">        ----</span>

<span class="sd">        **Finite strains (total equilibrium formulation, \</span>
<span class="sd">                          total primary unknowns):**</span>

<span class="sd">            *Equilibrium residuals*</span>

<span class="sd">                .. math::</span>

<span class="sd">                   \\boldsymbol{R}^{(I)}_{n+1} =</span>
<span class="sd">                   \\boldsymbol{F}_{\\mu,\\,n+1}^{(I)}</span>
<span class="sd">                   + \\sum^{n_{\\text{c}}}_{J=1}</span>
<span class="sd">                   \\boldsymbol{\\mathsf{T}}^{(I)(J)} : \\left(</span>
<span class="sd">                   \\hat{\\boldsymbol{P}}_{\\mu,\\,n+1}^{(J)}</span>
<span class="sd">                   - \\boldsymbol{\\mathsf{A}}^{e,\\, 0}:</span>
<span class="sd">                   \\boldsymbol{F}_{\\mu,\\,n+1}^{(J)} \\right)</span>
<span class="sd">                   - \\boldsymbol{F}_{\\mu,\\,n+1}^{0} \\, ,</span>

<span class="sd">                .. math::</span>

<span class="sd">                   \\forall I = 1, \\, \\dots, \\, n_{\\text{c}} \\, ,</span>

<span class="sd">                where :math:`\\boldsymbol{R}^{(I)}_{n+1}` is the :math:`I` th</span>
<span class="sd">                material cluster equilibrium residual function,</span>
<span class="sd">                :math:`\\boldsymbol{F}_{\\mu,\\,n+1}^{(I)}` is the :math:`I` th</span>
<span class="sd">                material cluster deformation gradient,</span>
<span class="sd">                :math:`\\boldsymbol{\\mathsf{T}}^{(I)(J)}` is the cluster</span>
<span class="sd">                interaction tensor (fourth-order tensor) between the</span>
<span class="sd">                :math:`I` th and :math:`J` th material clusters,</span>
<span class="sd">                :math:`\\boldsymbol{P}_{\\mu,\\,n+1}^{(J)}` is the :math:`J` th</span>
<span class="sd">                material cluster first Piola-Kirchhoff stress tensor</span>
<span class="sd">                (:math:`\\hat{(\\cdot)}` denotes the incremental nature of the</span>
<span class="sd">                constitutive function),</span>
<span class="sd">                :math:`\\boldsymbol{\\mathsf{A}}^{e,\\, 0}` is the elastic</span>
<span class="sd">                tangent modulus of the reference homogeneous material,</span>
<span class="sd">                :math:`\\boldsymbol{F}_{\\mu,\\,n+1}^{0}` is the far-field</span>
<span class="sd">                deformation gradient, :math:`n_{c}` is the number of material</span>
<span class="sd">                clusters, and :math:`n+1` denotes the current increment.</span>


<span class="sd">            *Loading (homogenization-based) strain and/or stress constraints*</span>

<span class="sd">                .. math::</span>

<span class="sd">                   \\boldsymbol{R}^{(n_{\\text{c}} + 1)}_{n+1} =</span>
<span class="sd">                   \\sum^{n_{\\text{c}}}_{I=1} f^{(I)}</span>
<span class="sd">                   \\boldsymbol{F}_{\\mu,\\,n+1}^{(I)}</span>
<span class="sd">                   - \\boldsymbol{F}_{n+1}  \\, ,</span>

<span class="sd">                where :math:`\\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}` is the</span>
<span class="sd">                strain loading constraint residual function,</span>
<span class="sd">                :math:`f^{(I)}` is the volume fraction of the :math:`I` th</span>
<span class="sd">                material cluster, :math:`\\boldsymbol{F}_{\\mu,\\,n+1}^{(I)}`</span>
<span class="sd">                is the :math:`I` th material cluster deformation gradient,</span>
<span class="sd">                :math:`\\boldsymbol{F}_{n+1}` is the macroscale deformation</span>
<span class="sd">                gradient, :math:`n_{c}` is the number of material clusters, and</span>
<span class="sd">                :math:`n+1` denotes the current increment.</span>

<span class="sd">                .. math::</span>

<span class="sd">                    \\boldsymbol{R}^{(n_{\\text{c}} + 1)}_{n+1} =</span>
<span class="sd">                    \\sum^{n_{\\text{c}}}_{I=1} f^{(I)}</span>
<span class="sd">                    \\hat{\\boldsymbol{P}}_{\\mu,\\,n+1}^{(I)}</span>
<span class="sd">                    - \\boldsymbol{P}_{n+1}</span>

<span class="sd">                where :math:`\\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}` is the</span>
<span class="sd">                stress loading constraint residual function, :math:`f^{(I)}` is</span>
<span class="sd">                the volume fraction of the :math:`I` th material cluster,</span>
<span class="sd">                :math:`\\boldsymbol{P}_{\\mu, \\,n+1}^{(I)}` is the</span>
<span class="sd">                :math:`I` th material cluster first Piola-Kirchhoff stress</span>
<span class="sd">                tensor (:math:`\\hat{(\\cdot)}` denotes the incremental nature</span>
<span class="sd">                of the constitutive function), :math:`\\boldsymbol{P}_{n+1}` is</span>
<span class="sd">                the macroscale first Piola-Kirchhoff stress tensor,</span>
<span class="sd">                :math:`n_{c}` is the number of material clusters, and</span>
<span class="sd">                :math:`n+1` denotes the current increment.</span>

<span class="sd">        ----</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crve : CRVE</span>
<span class="sd">            Cluster-Reduced Representative Volume Element.</span>
<span class="sd">        material_state : MaterialState</span>
<span class="sd">            CRVE material constitutive state.</span>
<span class="sd">        presc_strain_idxs : list[int]</span>
<span class="sd">            Prescribed macroscale loading strain components indexes.</span>
<span class="sd">        presc_stress_idxs : list[int]</span>
<span class="sd">            Prescribed macroscale loading stress components indexes.</span>
<span class="sd">        applied_mac_load_mf : dict</span>
<span class="sd">            For each prescribed loading nature type</span>
<span class="sd">            (key, {&#39;strain&#39;, &#39;stress&#39;}), stores the current applied macroscale</span>
<span class="sd">            loading constraints in a numpy.ndarray of shape (n_comps,).</span>
<span class="sd">        ref_material : ElasticReferenceMaterial</span>
<span class="sd">            Elastic reference material.</span>
<span class="sd">        global_cit_mf : numpy.ndarray (2d)</span>
<span class="sd">            Global cluster interaction matrix. Assembly positions are assigned</span>
<span class="sd">            according to the order of material_phases (1st) and phase_clusters</span>
<span class="sd">            (2nd).</span>
<span class="sd">        global_strain_mf : numpy.ndarray (1d)</span>
<span class="sd">            Global vector of clusters strain tensors (matricial form).</span>
<span class="sd">        inc_mac_load_mf : dict, default=None</span>
<span class="sd">            For each loading nature type (key, {&#39;strain&#39;, &#39;stress&#39;}), stores</span>
<span class="sd">            the incremental loading constraint matricial form in a</span>
<span class="sd">            numpy.ndarray of shape (n_comps,).</span>
<span class="sd">        farfield_strain_mf : numpy.ndarray (1d), default=None</span>
<span class="sd">            Far-field strain tensor (matricial form).</span>
<span class="sd">        farfield_strain_old_mf : numpy.ndarray (1d), default=None</span>
<span class="sd">            Last converged far-field strain tensor (matricial form).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        residual : numpy.ndarray (1d)</span>
<span class="sd">            Lippmann-Schwinger equilibrium residual vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set strain/stress components order according to problem strain</span>
        <span class="c1"># formulation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown problem strain formulation.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get material phases</span>
        <span class="n">material_phases</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_material_phases</span><span class="p">()</span>
        <span class="c1"># Get clusters associated with each material phase</span>
        <span class="n">phase_clusters</span> <span class="o">=</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_phase_clusters</span><span class="p">()</span>
        <span class="c1"># Get total number of clusters</span>
        <span class="n">n_total_clusters</span> <span class="o">=</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_n_total_clusters</span><span class="p">()</span>
        <span class="c1"># Get clusters state variables</span>
        <span class="n">clusters_state</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_clusters_state</span><span class="p">()</span>
        <span class="c1"># Get elastic reference material tangent modulus (matricial form)</span>
        <span class="n">ref_elastic_tangent_mf</span> <span class="o">=</span> <span class="n">ref_material</span><span class="o">.</span><span class="n">get_elastic_tangent_mf</span><span class="p">()</span>
        <span class="c1"># Get homogenized strain and stress tensors (matricial form)</span>
        <span class="n">hom_strain_mf</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_strain_mf</span><span class="p">()</span>
        <span class="n">hom_stress_mf</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_stress_mf</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialiatize and get last converged variables</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="c1"># Get incremental homogenized strain and stress tensors</span>
            <span class="c1"># (matricial form)</span>
            <span class="n">inc_hom_strain_mf</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_inc_hom_strain_mf</span><span class="p">()</span>
            <span class="n">inc_hom_stress_mf</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_inc_hom_stress_mf</span><span class="p">()</span>
            <span class="c1"># Initialize last converged global vector of clusters strain</span>
            <span class="c1"># tensors</span>
            <span class="n">global_strain_old_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">global_strain_mf</span><span class="p">)</span>
            <span class="c1"># Initialize last converged clusters polarization stress</span>
            <span class="n">global_pol_stress_old_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">global_strain_mf</span><span class="p">)</span>
            <span class="c1"># Get last converged clusters state variables</span>
            <span class="n">clusters_state_old</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_clusters_state_old</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize clusters polarization stress</span>
        <span class="n">global_pol_stress_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">global_strain_mf</span><span class="p">)</span>
        <span class="c1"># Initialize material cluster strain range indexes</span>
        <span class="n">i_init</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i_end</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># Loop over material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="n">material_phases</span><span class="p">:</span>
            <span class="c1"># Loop over material phase clusters</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">phase_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]:</span>
                <span class="c1"># Compute material cluster stress (matricial form)</span>
                <span class="n">stress_mf</span> <span class="o">=</span> <span class="n">clusters_state</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)][</span><span class="s1">&#39;stress_mf&#39;</span><span class="p">]</span>
                <span class="c1"># Get material cluster strain (matricial form)</span>
                <span class="n">strain_mf</span> <span class="o">=</span> <span class="n">global_strain_mf</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">]</span>
                <span class="c1"># Add cluster polarization stress to global array</span>
                <span class="n">global_pol_stress_mf</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">stress_mf</span> <span class="o">-</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">ref_elastic_tangent_mf</span><span class="p">,</span> <span class="n">strain_mf</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Compute last converged polarization stress</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
                    <span class="c1"># Compute material cluster last converged stress</span>
                    <span class="c1"># (matricial form)</span>
                    <span class="n">stress_old_mf</span> <span class="o">=</span> \
                        <span class="n">clusters_state_old</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)][</span><span class="s1">&#39;stress_mf&#39;</span><span class="p">]</span>
                    <span class="c1"># Get last converged material cluster strain</span>
                    <span class="c1"># (matricial form)</span>
                    <span class="n">strain_old_mf</span> <span class="o">=</span> \
                        <span class="n">clusters_state_old</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)][</span><span class="s1">&#39;strain_mf&#39;</span><span class="p">]</span>
                    <span class="n">global_strain_old_mf</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">strain_old_mf</span>
                    <span class="c1"># Add last converged cluster polarization stress to global</span>
                    <span class="c1"># array</span>
                    <span class="n">global_pol_stress_old_mf</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">stress_old_mf</span> \
                        <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">ref_elastic_tangent_mf</span><span class="p">,</span> <span class="n">strain_old_mf</span><span class="p">)</span>
                <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
                <span class="c1"># Update cluster strain range indexes</span>
                <span class="n">i_init</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                <span class="n">i_end</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize residual vector</span>
        <span class="n">residual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                            <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">))</span>
        <span class="c1"># Compute clusters equilibrium residuals</span>
        <span class="n">residual</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)]</span> <span class="o">=</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">global_strain_mf</span><span class="p">,</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">global_cit_mf</span><span class="p">,</span> <span class="n">global_pol_stress_mf</span><span class="p">)),</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">matlib</span><span class="o">.</span><span class="n">repmat</span><span class="p">(</span><span class="n">farfield_strain_mf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                                    <span class="n">n_total_clusters</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Add residual term for compatibility with incremental formulation</span>
        <span class="c1"># under infinitesimal strains</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">residual</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">global_strain_old_mf</span><span class="p">,</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">global_cit_mf</span><span class="p">,</span>
                                     <span class="n">global_pol_stress_old_mf</span><span class="p">)),</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">matlib</span><span class="o">.</span><span class="n">repmat</span><span class="p">(</span><span class="n">farfield_strain_old_mf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                                        <span class="n">n_total_clusters</span><span class="p">)),</span>
                <span class="p">(</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">),))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute homogenization constraints residuals</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">presc_strain_idxs</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
                    <span class="c1"># Constraint compatible with incremental formulation</span>
                    <span class="c1"># under infinitesimal strains</span>
                    <span class="n">residual</span><span class="p">[</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">inc_hom_strain_mf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">inc_mac_load_mf</span><span class="p">[</span><span class="s1">&#39;strain&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">residual</span><span class="p">[</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">hom_strain_mf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">applied_mac_load_mf</span><span class="p">[</span><span class="s1">&#39;strain&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
                    <span class="c1"># Constraint compatible with incremental formulation</span>
                    <span class="c1"># under infinitesimal strains</span>
                    <span class="n">residual</span><span class="p">[</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">inc_hom_stress_mf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">inc_mac_load_mf</span><span class="p">[</span><span class="s1">&#39;stress&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">residual</span><span class="p">[</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">hom_stress_mf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">applied_mac_load_mf</span><span class="p">[</span><span class="s1">&#39;stress&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">residual</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._build_jacobian"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._build_jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">_build_jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crve</span><span class="p">,</span> <span class="n">material_state</span><span class="p">,</span> <span class="n">presc_strain_idxs</span><span class="p">,</span>
                        <span class="n">presc_stress_idxs</span><span class="p">,</span> <span class="n">global_cit_diff_tangent_mf</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build Lippmann-Schwinger equilibrium Jacobian matrix.</span>

<span class="sd">        *Infinitesimal strains:*</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\boldsymbol{J}_{n+1} =</span>
<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}_{n+1}}{\\partial \\Delta</span>
<span class="sd">           \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}} = \\begin{bmatrix}</span>
<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}^{(I)}_{n+1}}{\\partial</span>
<span class="sd">           \\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(K)}} &amp;</span>
<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}^{(I)}_{n+1}}{\\partial</span>
<span class="sd">           \\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{0}} \\\\[8pt]</span>
<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}^{(n_{\\text{c}} + 1)}_{n+1}</span>
<span class="sd">           }{\\partial</span>
<span class="sd">           \\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(K)}} &amp;</span>
<span class="sd">           \\dfrac{\\partial</span>
<span class="sd">           \\boldsymbol{R}^{(n_{\\text{c}} + 1)}_{n+1}}{\\partial</span>
<span class="sd">           \\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{0}}</span>
<span class="sd">           \\end{bmatrix} \\, , \\qquad \\forall I, \\, K=1, \\, \\dots,</span>
<span class="sd">           \\, n_{\\text{c}} \\, ,</span>

<span class="sd">        where :math:`\\boldsymbol{R}_{n+1}` is the global residual function</span>
<span class="sd">        (assuming incremental equilibrium formulation and incremental</span>
<span class="sd">        primary unknowns), :math:`\\boldsymbol{R}^{(I)}_{n+1}` is the</span>
<span class="sd">        :math:`I` th material cluster equilibrium residual function,</span>
<span class="sd">        :math:`\\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}` is the strain</span>
<span class="sd">        and/or stress loading constraints residual function,</span>
<span class="sd">        :math:`\\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(K)}` is</span>
<span class="sd">        the :math:`K` th material cluster incremental infinitesimal strain</span>
<span class="sd">        tensor,</span>
<span class="sd">        :math:`\\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{0}` is the</span>
<span class="sd">        incremental far-field infinitesimal strain tensor, :math:`n_{c}` is</span>
<span class="sd">        the number of material clusters, and :math:`n+1` denotes the</span>
<span class="sd">        current increment.</span>

<span class="sd">        The partial derivatives are defined as</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}^{(I)}_{n+1}}{\\partial</span>
<span class="sd">           \\Delta \\boldsymbol{\\varepsilon}_{\\mu, \\, n+1}^{(K)}} =</span>
<span class="sd">           \\delta_{(I)(K)} \\boldsymbol{\\mathsf{I}} +</span>
<span class="sd">           \\boldsymbol{\\mathsf{T}}^{(I)(K)} : \\left(</span>
<span class="sd">           \\boldsymbol{\\mathsf{D}}^{(K)}_{n+1}</span>
<span class="sd">           - \\boldsymbol{\\mathsf{D}}^{e,\\, 0} \\right) \\, ,</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}^{(I)}_{n+1}}{\\partial</span>
<span class="sd">           \\Delta \\boldsymbol{\\varepsilon}_{\\mu, \\, n+1}^{0}} =</span>
<span class="sd">           - \\boldsymbol{\\mathsf{I}} \\, ,</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\text{strain:} \\; \\dfrac{\\partial</span>
<span class="sd">           \\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}}{\\partial \\Delta</span>
<span class="sd">           \\boldsymbol{\\varepsilon}_{\\mu, \\, n+1}^{(K)}} =  f^{(K)} \\,</span>
<span class="sd">           \\boldsymbol{\\mathsf{I}}   \\, ,  \\quad</span>
<span class="sd">           \\text{stress:} \\; \\dfrac{\\partial</span>
<span class="sd">           \\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}}{\\partial \\Delta</span>
<span class="sd">           \\boldsymbol{\\varepsilon}_{\\mu, \\, n+1}^{(K)}} =  f^{(K)} \\,</span>
<span class="sd">           \\boldsymbol{\\mathsf{D}}^{(K)}_{n+1} \\, ,</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}^{(n_{\\text{c}} + 1)}_{n+1}</span>
<span class="sd">           }{\\partial</span>
<span class="sd">           \\Delta \\boldsymbol{\\varepsilon}_{\\mu, \\, n+1}^{0}} =</span>
<span class="sd">           \\mathbf{0} \\, ,</span>

<span class="sd">        where :math:`\\delta_{(I)(K)}` is the Kronecker delta,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{I}}` is the fourth-order identity</span>
<span class="sd">        tensor, :math:`\\boldsymbol{\\mathsf{T}}^{(I)(K)}` is the cluster</span>
<span class="sd">        interaction tensor (fourth-order tensor) between the :math:`I` th</span>
<span class="sd">        and :math:`K` th material clusters,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{D}}^{(K)}_{n+1}` is the consistent</span>
<span class="sd">        tangent modulus of the :math:`K` th material cluster,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{D}}^{e,\\, 0}` is the elastic tangent</span>
<span class="sd">        modulus of the reference homogeneous material, :math:`f^{(K)}` is</span>
<span class="sd">        the volume fraction of the :math:`K` th material cluster.</span>

<span class="sd">        **Remark:** The Jacobian matrix is the same when the residual</span>
<span class="sd">        functions are derived with respect to the total strains (assuming</span>
<span class="sd">        incremental equilibrium formulation and total primary unknowns).</span>

<span class="sd">        ----</span>

<span class="sd">        *Finite strains:*</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\boldsymbol{J}_{n+1} =</span>
<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}_{n+1}}{\\partial</span>
<span class="sd">           \\boldsymbol{F}_{\\mu,\\,n+1}} = \\begin{bmatrix}</span>
<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}^{(I)}_{n+1}}{\\partial</span>
<span class="sd">           \\boldsymbol{F}_{\\mu,\\,n+1}^{(K)}} &amp;  \\dfrac{\\partial</span>
<span class="sd">           \\boldsymbol{R}^{(I)}_{n+1}}{\\partial</span>
<span class="sd">           \\boldsymbol{F}_{\\mu,\\,n+1}^{0}} \\\\[8pt]</span>
<span class="sd">           \\dfrac{\\partial</span>
<span class="sd">           \\boldsymbol{R}^{(n_{\\text{c}} + 1)}_{n+1}}{\\partial</span>
<span class="sd">           \\boldsymbol{F}_{\\mu,\\,n+1}^{(K)}} &amp;  \\dfrac{\\partial</span>
<span class="sd">           \\boldsymbol{R}^{(n_{\\text{c}} + 1)}_{n+1}}{\\partial</span>
<span class="sd">           \\boldsymbol{F}_{\\mu,\\,n+1}^{0}}</span>
<span class="sd">           \\end{bmatrix} \\, , \\qquad \\forall I, \\, K=1, \\, \\dots,</span>
<span class="sd">           \\, n_{\\text{c}} \\, ,</span>

<span class="sd">        where :math:`\\boldsymbol{R}_{n+1}` is the global residual</span>
<span class="sd">        function, :math:`\\boldsymbol{R}^{(I)}_{n+1}` is the :math:`I` th</span>
<span class="sd">        material cluster equilibrium residual function,</span>
<span class="sd">        :math:`\\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}` is the strain</span>
<span class="sd">        and/or stress loading constraints residual function,</span>
<span class="sd">        :math:`\\boldsymbol{F}_{\\mu,\\,n+1}^{(K)}` is the :math:`K` th</span>
<span class="sd">        material cluster deformation gradient,</span>
<span class="sd">        :math:`\\boldsymbol{F}_{\\mu,\\,n+1}^{0}` is the far-field</span>
<span class="sd">        deformation gradient, :math:`n_{c}` is the number of material</span>
<span class="sd">        clusters, and :math:`n+1` denotes the current increment.</span>

<span class="sd">        The partial derivatives are defined as</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}^{(I)}_{n+1}}{\\partial</span>
<span class="sd">           \\boldsymbol{F}_{\\mu, \\, n+1}^{(K)}} = \\delta_{(I)(K)}</span>
<span class="sd">           \\boldsymbol{\\mathsf{I}} +  \\boldsymbol{\\mathsf{T}}^{(I)(K)}</span>
<span class="sd">           : \\left( \\boldsymbol{\\mathsf{A}}^{(K)}_{n+1}</span>
<span class="sd">           - \\boldsymbol{\\mathsf{A}}^{e,\\, 0}   \\right) \\, ,</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}^{(I)}_{n+1}}{\\partial</span>
<span class="sd">           \\boldsymbol{F}_{\\mu, \\, n+1}^{0}} =</span>
<span class="sd">           - \\boldsymbol{\\mathsf{I}} \\, ,</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\text{strain:} \\; \\dfrac{\\partial</span>
<span class="sd">           \\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}}{\\partial</span>
<span class="sd">           \\boldsymbol{F}_{\\mu, \\, n+1}^{(K)}} =  f^{(K)} \\,</span>
<span class="sd">           \\boldsymbol{\\mathsf{I}}   \\, ,  \\quad</span>
<span class="sd">           \\text{stress:} \\; \\dfrac{\\partial</span>
<span class="sd">           \\boldsymbol{R}^{(n_{\\text{c}}+1)}_{n+1}}{\\partial</span>
<span class="sd">           \\boldsymbol{F}_{\\mu, \\, n+1}^{(K)}} =  f^{(K)} \\,</span>
<span class="sd">           \\boldsymbol{\\mathsf{A}}^{(K)}_{n+1} \\, ,</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}^{(n_{\\text{c}} + 1)}_{n+1}</span>
<span class="sd">           }{\\partial \\boldsymbol{F}_{\\mu, \\, n+1}^{0}} = \\mathbf{0}</span>
<span class="sd">           \\, ,</span>

<span class="sd">        where :math:`\\delta_{(I)(K)}` is the Kronecker delta,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{I}}` is the fourth-order identity</span>
<span class="sd">        tensor, :math:`\\boldsymbol{\\mathsf{T}}^{(I)(K)}` is the cluster</span>
<span class="sd">        interaction tensor (fourth-order tensor) between the :math:`I` th</span>
<span class="sd">        and :math:`K` th material clusters,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{A}}^{(K)}_{n+1}` is the material</span>
<span class="sd">        consistent tangent modulus of the :math:`K` th material cluster,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{A}}^{e,\\, 0}` is the elastic tangent</span>
<span class="sd">        modulus of the reference homogeneous material, :math:`f^{(K)}` is</span>
<span class="sd">        the volume fraction of the :math:`K` th material cluster.</span>

<span class="sd">        ----</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crve : CRVE</span>
<span class="sd">            Cluster-Reduced Representative Volume Element.</span>
<span class="sd">        material_state : MaterialState</span>
<span class="sd">            CRVE material constitutive state.</span>
<span class="sd">        global_cit_diff_tangent_mf : numpy.ndarray (2d)</span>
<span class="sd">            Global matrix similar to global cluster interaction matrix but</span>
<span class="sd">            where each cluster interaction tensor is double contracted with the</span>
<span class="sd">            difference between the associated material cluster consistent</span>
<span class="sd">            tangent modulus and the elastic reference material tangent modulus.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jacobian : numpy.ndarray (2d)</span>
<span class="sd">            Lippmann-Schwinger equilibrium Jacobian matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set strain/stress components order according to problem strain</span>
        <span class="c1"># formulation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown problem strain formulation.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">foid</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">fosym</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">get_id_operators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="c1"># Set fourth-order symmetric projection tensor (matricial form)</span>
            <span class="n">fosym_mf</span> <span class="o">=</span> <span class="n">mop</span><span class="o">.</span><span class="n">get_tensor_mf</span><span class="p">(</span><span class="n">fosym</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Set fourth-order identity tensor (matricial form)</span>
            <span class="n">foid_mf</span> <span class="o">=</span> <span class="n">mop</span><span class="o">.</span><span class="n">get_tensor_mf</span><span class="p">(</span><span class="n">foid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get material phases</span>
        <span class="n">material_phases</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_material_phases</span><span class="p">()</span>
        <span class="c1"># Get clusters associated with each material phase</span>
        <span class="n">phase_clusters</span> <span class="o">=</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_phase_clusters</span><span class="p">()</span>
        <span class="c1"># Get total number of clusters</span>
        <span class="n">n_total_clusters</span> <span class="o">=</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_n_total_clusters</span><span class="p">()</span>
        <span class="c1"># Get clusters volume fraction</span>
        <span class="n">clusters_vf</span> <span class="o">=</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_clusters_vf</span><span class="p">()</span>
        <span class="c1"># Get material consistent tangent modulus associated with each material</span>
        <span class="c1"># cluster</span>
        <span class="n">clusters_tangent_mf</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_clusters_tangent_mf</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize Jacobian matrix</span>
        <span class="n">jacobian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                               <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">),))</span>
        <span class="c1"># Compute Jacobian matrix component 11</span>
        <span class="n">i_init</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i_end</span> <span class="o">=</span> <span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
        <span class="n">j_init</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">j_end</span> <span class="o">=</span> <span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">jacobian</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">,</span> <span class="n">j_init</span><span class="p">:</span><span class="n">j_end</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="p">[</span><span class="n">fosym_mf</span><span class="p">,</span> <span class="p">]))</span> \
                <span class="o">+</span> <span class="n">global_cit_diff_tangent_mf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jacobian</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">,</span> <span class="n">j_init</span><span class="p">:</span><span class="n">j_end</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="p">[</span><span class="n">foid_mf</span><span class="p">,</span> <span class="p">]))</span> \
                <span class="o">+</span> <span class="n">global_cit_diff_tangent_mf</span>
        <span class="c1"># Compute Jacobian matrix component 12</span>
        <span class="n">i_init</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i_end</span> <span class="o">=</span> <span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
        <span class="n">j_init</span> <span class="o">=</span> <span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
        <span class="n">j_end</span> <span class="o">=</span> <span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">jacobian</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">,</span> <span class="n">j_init</span><span class="p">:</span><span class="n">j_end</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">numpy</span><span class="o">.</span><span class="n">matlib</span><span class="o">.</span><span class="n">repmat</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">fosym_mf</span><span class="p">,</span> <span class="n">n_total_clusters</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">jacobian</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">,</span> <span class="n">j_init</span><span class="p">:</span><span class="n">j_end</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">numpy</span><span class="o">.</span><span class="n">matlib</span><span class="o">.</span><span class="n">repmat</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="o">*</span><span class="n">foid_mf</span><span class="p">,</span> <span class="n">n_total_clusters</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Compute Jacobian matrix component 21</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span>
            <span class="n">jclst</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="n">material_phases</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">phase_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">presc_strain_idxs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
                            <span class="n">f_foid_mf</span> <span class="o">=</span> <span class="n">clusters_vf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span><span class="o">*</span><span class="n">fosym_mf</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">f_foid_mf</span> <span class="o">=</span> <span class="n">clusters_vf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span><span class="o">*</span><span class="n">foid_mf</span>
                        <span class="n">j_init</span> <span class="o">=</span> <span class="n">jclst</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                        <span class="n">j_end</span> <span class="o">=</span> <span class="n">j_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                        <span class="n">jacobian</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j_init</span><span class="p">:</span><span class="n">j_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_foid_mf</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">vf_tangent_mf</span> <span class="o">=</span> <span class="n">clusters_vf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>\
                            <span class="o">*</span> <span class="n">clusters_tangent_mf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>
                        <span class="n">j_init</span> <span class="o">=</span> <span class="n">jclst</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                        <span class="n">j_end</span> <span class="o">=</span> <span class="n">j_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                        <span class="n">jacobian</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j_init</span><span class="p">:</span><span class="n">j_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">vf_tangent_mf</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:]</span>
                    <span class="c1"># Increment column cluster index</span>
                    <span class="n">jclst</span> <span class="o">=</span> <span class="n">jclst</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">jacobian</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._build_global_cit_diff_tangent_mf"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._build_global_cit_diff_tangent_mf">[docs]</a>    <span class="k">def</span> <span class="nf">_build_global_cit_diff_tangent_mf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crve</span><span class="p">,</span> <span class="n">global_cit_mf</span><span class="p">,</span>
                                          <span class="n">material_state</span><span class="p">,</span> <span class="n">ref_material</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build global cluster interaction - tangent modulus matrix.</span>

<span class="sd">        *Infinitesimal strains:*</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\boldsymbol{\\mathsf{T}}^{(I)(K)} : \\left(</span>
<span class="sd">           \\boldsymbol{\\mathsf{D}}^{(K)}_{n+1}</span>
<span class="sd">           - \\boldsymbol{\\mathsf{D}}^{e,\\, 0} \\right) \\, ,</span>
<span class="sd">           \\qquad \\forall I, \\, K=1, \\, \\dots, \\, n_{\\text{c}} \\, ,</span>

<span class="sd">        where :math:`\\boldsymbol{\\mathsf{T}}^{(I)(K)}` is the cluster</span>
<span class="sd">        interaction tensor (fourth-order tensor) between the :math:`I` th and</span>
<span class="sd">        :math:`K` th material clusters,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{D}}^{(K)}_{n+1}` is the consistent tangent</span>
<span class="sd">        modulus of the :math:`K` th material cluster,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{D}}^{e,\\, 0}` is the elastic tangent</span>
<span class="sd">        modulus of the reference homogeneous material, :math:`n_{c}` is the</span>
<span class="sd">        number of material clusters. and :math:`n+1` denotes the current</span>
<span class="sd">        increment.</span>

<span class="sd">        ----</span>

<span class="sd">        *Finite strains:*</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\boldsymbol{\\mathsf{T}}^{(I)(K)} : \\left(</span>
<span class="sd">           \\boldsymbol{\\mathsf{A}}^{(K)}_{n+1}</span>
<span class="sd">           - \\boldsymbol{\\mathsf{A}}^{e,\\, 0} \\right) \\, ,</span>
<span class="sd">           \\qquad \\forall I, \\, K=1, \\, \\dots, \\, n_{\\text{c}} \\, ,</span>

<span class="sd">        where :math:`\\boldsymbol{\\mathsf{T}}^{(I)(K)}` is the cluster</span>
<span class="sd">        interaction tensor (fourth-order tensor) between the :math:`I` th and</span>
<span class="sd">        :math:`K` th material clusters,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{A}}^{(K)}_{n+1}` is the material</span>
<span class="sd">        consistent tangent modulus of the :math:`K` th material cluster,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{A}}^{e,\\, 0}` is the elastic tangent</span>
<span class="sd">        modulus of the reference homogeneous material, :math:`n_{c}` is the</span>
<span class="sd">        number of material clusters. and :math:`n+1` denotes the current</span>
<span class="sd">        increment.</span>

<span class="sd">        ----</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crve : CRVE</span>
<span class="sd">            Cluster-Reduced Representative Volume Element.</span>
<span class="sd">        global_cit_mf : numpy.ndarray (2d)</span>
<span class="sd">            Global cluster interaction matrix. Assembly positions are assigned</span>
<span class="sd">            according to the order of material_phases (1st) and phase_clusters</span>
<span class="sd">            (2nd).</span>
<span class="sd">        material_state : MaterialState</span>
<span class="sd">            CRVE material constitutive state.</span>
<span class="sd">        ref_material : ElasticReferenceMaterial</span>
<span class="sd">            Elastic reference material.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        global_cit_diff_tangent_mf : numpy.ndarray (2d)</span>
<span class="sd">            Global matrix similar to the global cluster interaction matrix but</span>
<span class="sd">            where each cluster interaction tensor is double contracted with the</span>
<span class="sd">            difference between the associated material cluster consistent</span>
<span class="sd">            tangent modulus and the reference material elastic tangent modulus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get material consistent tangent modulus associated with each material</span>
        <span class="c1"># cluster</span>
        <span class="n">clusters_tangent_mf</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_clusters_tangent_mf</span><span class="p">()</span>
        <span class="c1"># Get elastic reference material tangent modulus</span>
        <span class="n">ref_elastic_tangent_mf</span> <span class="o">=</span> <span class="n">ref_material</span><span class="o">.</span><span class="n">get_elastic_tangent_mf</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build list which stores the difference between the material cluster</span>
        <span class="c1"># consistent tangent modulus (matricial form) and the reference</span>
        <span class="c1"># material elastic tangent modulus (matricial form)</span>
        <span class="n">diff_tangent_mf</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># Loop over material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_material_phases</span><span class="p">():</span>
            <span class="c1"># Loop over material clusters</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_phase_clusters</span><span class="p">()[</span><span class="n">mat_phase</span><span class="p">]:</span>
                <span class="n">diff_tangent_mf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clusters_tangent_mf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>
                                       <span class="o">-</span> <span class="n">ref_elastic_tangent_mf</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build global matrix similar to the global cluster interaction matrix</span>
        <span class="c1"># but where each cluster interaction tensor is double contracted with</span>
        <span class="c1"># the difference between the associated material cluster consistent</span>
        <span class="c1"># tangent modulus and the reference material elastic tangent modulus</span>
        <span class="n">global_cit_diff_tangent_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span>
            <span class="n">global_cit_mf</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">diff_tangent_mf</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">global_cit_diff_tangent_mf</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._check_convergence"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._check_convergence">[docs]</a>    <span class="k">def</span> <span class="nf">_check_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crve</span><span class="p">,</span> <span class="n">material_state</span><span class="p">,</span> <span class="n">presc_strain_idxs</span><span class="p">,</span>
                           <span class="n">presc_stress_idxs</span><span class="p">,</span> <span class="n">applied_mac_load_mf</span><span class="p">,</span> <span class="n">residual</span><span class="p">,</span>
                           <span class="n">applied_mix_strain_mf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check Lippmann-Schwinger equilibrium convergence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crve : CRVE</span>
<span class="sd">            Cluster-Reduced Representative Volume Element.</span>
<span class="sd">        material_state : MaterialState</span>
<span class="sd">            CRVE material constitutive state.</span>
<span class="sd">        presc_strain_idxs : list[int]</span>
<span class="sd">            Prescribed macroscale loading strain components indexes.</span>
<span class="sd">        presc_stress_idxs : list[int]</span>
<span class="sd">            Prescribed macroscale loading stress components indexes.</span>
<span class="sd">        applied_mac_load_mf : dict</span>
<span class="sd">            For each prescribed loading nature type</span>
<span class="sd">            (key, {&#39;strain&#39;, &#39;stress&#39;}), stores the current applied loading</span>
<span class="sd">            constraints in a numpy.ndarray of shape (n_comps,).</span>
<span class="sd">        residual : numpy.ndarray (1d)</span>
<span class="sd">            Lippmann-Schwinger equilibrium residual vector.</span>
<span class="sd">        applied_mix_strain_mf : numpy.ndarray (1d), default=None</span>
<span class="sd">            Strain tensor (matricial form) that contains prescribed strain</span>
<span class="sd">            components and (non-prescribed) homogenized strain components.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_converged : bool</span>
<span class="sd">            True if Lippmann-Schwinger equilibrium iterative solution</span>
<span class="sd">            converged, False otherwise.</span>
<span class="sd">        errors : list[float]</span>
<span class="sd">            List of errors associated with the Lippmann-Schwinger equilibrium</span>
<span class="sd">            convergence evaluation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize convergence flag</span>
        <span class="n">is_converged</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set strain/stress components order according to problem strain</span>
        <span class="c1"># formulation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown problem strain formulation.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get total number of clusters</span>
        <span class="n">n_total_clusters</span> <span class="o">=</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_n_total_clusters</span><span class="p">()</span>
        <span class="c1"># Compute number of prescribed loading strain components</span>
        <span class="n">n_presc_strain</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">presc_strain_idxs</span><span class="p">)</span>
        <span class="c1"># Compute number of prescribed loading stress components</span>
        <span class="n">n_presc_stress</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">presc_stress_idxs</span><span class="p">)</span>
        <span class="c1"># Get homogenized strain and stress tensors (matricial form)</span>
        <span class="n">hom_strain_mf</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_strain_mf</span><span class="p">()</span>
        <span class="n">hom_stress_mf</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_hom_stress_mf</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set strain and stress normalization factors</span>
        <span class="k">if</span> <span class="n">n_presc_strain</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
            <span class="n">applied_mac_load_mf</span><span class="p">[</span><span class="s1">&#39;strain&#39;</span><span class="p">][</span><span class="nb">tuple</span><span class="p">([</span><span class="n">presc_strain_idxs</span><span class="p">])],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">applied_mac_load_mf</span><span class="p">[</span><span class="s1">&#39;strain&#39;</span><span class="p">][</span><span class="nb">tuple</span><span class="p">([</span>
                     <span class="n">presc_strain_idxs</span><span class="p">])]</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
            <span class="n">strain_norm_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">applied_mac_load_mf</span><span class="p">[</span><span class="s1">&#39;strain&#39;</span><span class="p">][</span><span class="nb">tuple</span><span class="p">([</span><span class="n">presc_strain_idxs</span><span class="p">])])</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">hom_strain_mf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">hom_strain_mf</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                             <span class="n">atol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
            <span class="n">strain_norm_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">hom_strain_mf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">strain_norm_factor</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">n_presc_stress</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
            <span class="n">applied_mac_load_mf</span><span class="p">[</span><span class="s1">&#39;stress&#39;</span><span class="p">][</span><span class="nb">tuple</span><span class="p">([</span><span class="n">presc_stress_idxs</span><span class="p">])],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">applied_mac_load_mf</span><span class="p">[</span><span class="s1">&#39;stress&#39;</span><span class="p">][</span><span class="nb">tuple</span><span class="p">([</span>
                     <span class="n">presc_stress_idxs</span><span class="p">])]</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
            <span class="n">stress_norm_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span>
                <span class="n">applied_mac_load_mf</span><span class="p">[</span><span class="s1">&#39;stress&#39;</span><span class="p">][</span><span class="nb">tuple</span><span class="p">([</span><span class="n">presc_stress_idxs</span><span class="p">])])</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">hom_stress_mf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">hom_stress_mf</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                             <span class="n">atol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
            <span class="n">stress_norm_factor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">hom_stress_mf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stress_norm_factor</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute error associated with the clusters equilibrium residuals</span>
        <span class="n">error_1</span> <span class="o">=</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">residual</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)])</span> \
            <span class="o">/</span> <span class="n">strain_norm_factor</span>
        <span class="c1"># Compute error associated with the homogenization constraints</span>
        <span class="c1"># residuals</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">residual</span><span class="p">[</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">):]</span>
        <span class="k">if</span> <span class="n">n_presc_strain</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">error_2</span> <span class="o">=</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="n">presc_strain_idxs</span><span class="p">])</span><span class="o">/</span><span class="n">strain_norm_factor</span>
        <span class="k">if</span> <span class="n">n_presc_stress</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">error_3</span> <span class="o">=</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">aux</span><span class="p">[</span><span class="n">presc_stress_idxs</span><span class="p">])</span><span class="o">/</span><span class="n">stress_norm_factor</span>
        <span class="c1"># Criterion convergence flag is True if all residual errors</span>
        <span class="c1"># converged according to the defined convergence tolerance</span>
        <span class="k">if</span> <span class="n">n_presc_strain</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">error_2</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">is_converged</span> <span class="o">=</span> <span class="p">(</span><span class="n">error_1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_tol</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="n">error_3</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_tol</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">n_presc_stress</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">error_3</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">is_converged</span> <span class="o">=</span> <span class="p">(</span><span class="n">error_1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_tol</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="n">error_2</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_tol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_converged</span> <span class="o">=</span> <span class="p">(</span><span class="n">error_1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_tol</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="n">error_2</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_tol</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="n">error_3</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_tol</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build convergence evaluation errors list</span>
        <span class="n">errors</span> <span class="o">=</span> <span class="p">[</span><span class="n">error_1</span><span class="p">,</span> <span class="n">error_2</span><span class="p">,</span> <span class="n">error_3</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">is_converged</span><span class="p">,</span> <span class="n">errors</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._crve_effective_tangent_modulus"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._crve_effective_tangent_modulus">[docs]</a>    <span class="k">def</span> <span class="nf">_crve_effective_tangent_modulus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crve</span><span class="p">,</span> <span class="n">material_state</span><span class="p">,</span>
                                        <span class="n">global_cit_diff_tangent_mf</span><span class="p">,</span>
                                        <span class="n">global_strain_mf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">farfield_strain_mf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;CRVE tangent modulus and clusters strain concentration tensors.</span>

<span class="sd">        *Infinitesimal strains:*</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\overline{\\boldsymbol{\\mathsf{D}}}_{n+1} =</span>
<span class="sd">           \\sum^{n_{\\text{c}}}_{I=1} f^{(I)}</span>
<span class="sd">           \\boldsymbol{\\mathsf{D}}^{(I)}_{n+1} :</span>
<span class="sd">           \\boldsymbol{\\mathsf{H}}^{(I)}_{n+1} \\, ,</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\mathbf{H}^{(I)}_{n+1} = \\sum_{K=1}^{ n_{\\text{c}}}</span>
<span class="sd">           \\left( \\mathbf{M}^{-1} \\right)_{(I)(K)} \\, ,</span>
<span class="sd">           \\quad \\forall I = 1,2, \\, \\dots, \\, n_{\\text{c}} \\, ,</span>

<span class="sd">        .. math::</span>

<span class="sd">            \\mathbf{M} = \\begin{bmatrix}</span>
<span class="sd">            \\dfrac{\\partial \\boldsymbol{R}^{(1)}_{n+1}}{\\partial</span>
<span class="sd">            \\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(1)}} &amp; \\dots &amp;</span>
<span class="sd">            \\dfrac{\\partial \\boldsymbol{R}^{(1)}_{n+1}}{\\partial</span>
<span class="sd">            \\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(n_{\\text{c}})}}</span>
<span class="sd">            \\\\[10pt] \\vdots &amp; \\ddots &amp; \\vdots \\\\[5pt]</span>
<span class="sd">            \\dfrac{\\partial \\boldsymbol{R}^{(n_{\\mathrm{c}})}_{n+1}}{</span>
<span class="sd">            \\partial \\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(1)}} &amp;</span>
<span class="sd">            \\dots &amp; \\dfrac{\\partial</span>
<span class="sd">            \\boldsymbol{R}^{(n_{\\text{c}})}_{n+1}}{\\partial \\Delta</span>
<span class="sd">            \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(n_{\\text{c}})}}</span>
<span class="sd">            \\end{bmatrix} \\, ,</span>

<span class="sd">        where :math:`\\overline{\\boldsymbol{\\mathsf{D}}}_{n+1}` is the CRVE</span>
<span class="sd">        homogenized consistent tangent modulus, :math:`f^{(I)}` is the volume</span>
<span class="sd">        fraction of the :math:`I` th material cluster,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{D}}^{(I)}_{n+1}` is the consistent tangent</span>
<span class="sd">        modulus of the :math:`I` th material cluster,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{H}}^{(I)}_{n+1}` is the :math:`I` th</span>
<span class="sd">        material cluster strain concentration tensor,</span>
<span class="sd">        :math:`\\boldsymbol{R}^{(I)}_{n+1}` is the :math:`I` th material</span>
<span class="sd">        cluster equilibrium residual function,</span>
<span class="sd">        :math:`\\Delta \\boldsymbol{\\varepsilon}_{\\mu,\\,n+1}^{(K)}` is the</span>
<span class="sd">        :math:`K` th material cluster incremental infinitesimal strain tensor,</span>
<span class="sd">        :math:`n_{c}` is the number of material clusters, and :math:`n+1`</span>
<span class="sd">        denotes the current increment.</span>

<span class="sd">        The residual derivatives are defined as</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}^{(I)}_{n+1}}{\\partial</span>
<span class="sd">           \\Delta \\boldsymbol{\\varepsilon}_{\\mu, \\, n+1}^{(K)}} =</span>
<span class="sd">           \\delta_{(I)(K)} \\boldsymbol{\\mathsf{I}} +</span>
<span class="sd">           \\boldsymbol{\\mathsf{T}}^{(I)(K)} : \\left(</span>
<span class="sd">           \\boldsymbol{\\mathsf{D}}^{(K)}_{n+1} -</span>
<span class="sd">           \\boldsymbol{\\mathsf{D}}^{e,\\, 0} \\right) \\, ,</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\forall I, K = 1, \\, \\dots, \\, n_{\\text{c}} \\, .</span>

<span class="sd">        **Remark:** The residual derivatives are the same when the residual</span>
<span class="sd">        functions are derived with respect to the total strains.</span>

<span class="sd">        ----</span>

<span class="sd">        *Finite strains:*</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\overline{\\boldsymbol{\\mathsf{A}}}_{n+1} =</span>
<span class="sd">           \\sum^{n_{\\text{c}}}_{I=1} f^{(I)}</span>
<span class="sd">           \\boldsymbol{\\mathsf{A}}^{(I)}_{n+1} :</span>
<span class="sd">           \\boldsymbol{\\mathsf{H}}^{(I)}_{n+1} \\, ,</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\mathbf{H}^{(I)}_{n+1} = \\sum_{K=1}^{ n_{\\text{c}}} \\left(</span>
<span class="sd">           \\mathbf{M}^{-1} \\right)_{(I)(K)} \\, , \\quad</span>
<span class="sd">           \\forall I = 1,2, \\, \\dots, \\, n_{\\text{c}} \\, ,</span>

<span class="sd">        .. math::</span>

<span class="sd">            \\mathbf{M} = \\begin{bmatrix}</span>
<span class="sd">            \\dfrac{\\partial \\boldsymbol{R}^{(1)}_{n+1}}{\\partial</span>
<span class="sd">            \\boldsymbol{F}_{\\mu,\\,n+1}^{(1)}} &amp; \\dots &amp; \\dfrac{\\partial</span>
<span class="sd">            \\boldsymbol{R}^{(1)}_{n+1}}{\\partial</span>
<span class="sd">            \\boldsymbol{F}_{\\mu,\\,n+1}^{(n_{\\text{c}})}} \\\\[10pt]</span>
<span class="sd">            \\vdots &amp; \\ddots &amp; \\vdots \\\\[5pt] \\dfrac{\\partial</span>
<span class="sd">            \\boldsymbol{R}^{(n_{\\mathrm{c}})}_{n+1}}{\\partial</span>
<span class="sd">            \\boldsymbol{F}_{\\mu,\\,n+1}^{(1)}} &amp; \\dots &amp;</span>
<span class="sd">            \\dfrac{\\partial \\boldsymbol{R}^{(n_{\\text{c}})}_{n+1}}{</span>
<span class="sd">            \\partial \\boldsymbol{F}_{\\mu,\\,n+1}^{(n_{\\text{c}})}}</span>
<span class="sd">            \\end{bmatrix} \\, ,</span>

<span class="sd">        where :math:`\\overline{\\boldsymbol{\\mathsf{A}}}_{n+1}` is the CRVE</span>
<span class="sd">        homogenized material consistent tangent modulus, :math:`f^{(I)}` is the</span>
<span class="sd">        volume fraction of the :math:`I` th material cluster,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{A}}^{(I)}_{n+1}` is the material</span>
<span class="sd">        consistent tangent modulus of the :math:`I` th material cluster,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{H}}^{(I)}_{n+1}` is the :math:`I` th</span>
<span class="sd">        material cluster strain concentration tensor,</span>
<span class="sd">        :math:`\\boldsymbol{R}^{(I)}_{n+1}` is the :math:`I` th material</span>
<span class="sd">        cluster equilibrium residual function,</span>
<span class="sd">        :math:`\\boldsymbol{F}_{\\mu,\\,n+1}^{(K)}` is the :math:`K` th</span>
<span class="sd">        material cluster deformation gradient, :math:`n_{c}` is the number of</span>
<span class="sd">        material clusters, and :math:`n+1` denotes the current increment.</span>

<span class="sd">        The residual derivatives are defined as</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\dfrac{\\partial \\boldsymbol{R}^{(I)}_{n+1}}{\\partial</span>
<span class="sd">           \\boldsymbol{F}_{\\mu, \\, n+1}^{(K)}} = \\delta_{(I)(K)}</span>
<span class="sd">           \\boldsymbol{\\mathsf{I}} + \\boldsymbol{\\mathsf{T}}^{(I)(K)} :</span>
<span class="sd">           \\left( \\boldsymbol{\\mathsf{A}}^{(K)}_{n+1} -</span>
<span class="sd">           \\boldsymbol{\\mathsf{A}}^{e,\\, 0} \\right) \\, ,</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\forall I, K = 1, \\, \\dots, \\, n_{\\text{c}} \\, .</span>

<span class="sd">        ----</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crve : CRVE</span>
<span class="sd">            Cluster-Reduced Representative Volume Element.</span>
<span class="sd">        material_state : MaterialState</span>
<span class="sd">            CRVE material constitutive state.</span>
<span class="sd">        global_cit_diff_tangent_mf : numpy.ndarray (2d)</span>
<span class="sd">            Global matrix similar to global cluster interaction matrix but</span>
<span class="sd">            where each cluster interaction tensor is double contracted with the</span>
<span class="sd">            difference between the associated material cluster consistent</span>
<span class="sd">            tangent modulus and the elastic reference material tangent modulus.</span>
<span class="sd">        global_strain_mf : numpy.ndarray (1d), default=None</span>
<span class="sd">            Global vector of clusters strains stored in matricial form. Only</span>
<span class="sd">            required for validation of cluster strain concentration tensors</span>
<span class="sd">            computation.</span>
<span class="sd">        farfield_strain_mf : numpy.ndarray (1d), default=None</span>
<span class="sd">            Far-field strain tensor (matricial form). Only required for</span>
<span class="sd">            validation of cluster strain concentration tensors computation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eff_tangent_mf : numpy.ndarray (2d)</span>
<span class="sd">            CRVE effective material tangent modulus (matricial form).</span>
<span class="sd">        clusters_sct_mf : dict</span>
<span class="sd">            Fourth-order strain concentration tensor (matricial form)</span>
<span class="sd">            (item, numpy.ndarray (2d)) associated with each material cluster</span>
<span class="sd">            (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set strain/stress components order according to problem strain</span>
        <span class="c1"># formulation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown problem strain formulation.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set second-order identity tensor</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">foid</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">fosym</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">get_id_operators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span>
        <span class="n">fosym_mf</span> <span class="o">=</span> <span class="n">mop</span><span class="o">.</span><span class="n">get_tensor_mf</span><span class="p">(</span><span class="n">fosym</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span>
        <span class="n">foid_mf</span> <span class="o">=</span> <span class="n">mop</span><span class="o">.</span><span class="n">get_tensor_mf</span><span class="p">(</span><span class="n">foid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Get material phases</span>
        <span class="n">material_phases</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_material_phases</span><span class="p">()</span>
        <span class="c1"># Get clusters associated with each material phase</span>
        <span class="n">phase_clusters</span> <span class="o">=</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_phase_clusters</span><span class="p">()</span>
        <span class="c1"># Get total number of clusters</span>
        <span class="n">n_total_clusters</span> <span class="o">=</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_n_total_clusters</span><span class="p">()</span>
        <span class="c1"># Get clusters volume fraction</span>
        <span class="n">clusters_vf</span> <span class="o">=</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_clusters_vf</span><span class="p">()</span>
        <span class="c1"># Get material consistent tangent modulus associated with each material</span>
        <span class="c1"># cluster</span>
        <span class="n">clusters_tangent_mf</span> <span class="o">=</span> <span class="n">material_state</span><span class="o">.</span><span class="n">get_clusters_tangent_mf</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute equilibrium jacobian matrix (cluster strain concentration</span>
        <span class="c1"># tensors system of linear equations coefficient matrix)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">csct_matrix</span> <span class="o">=</span> \
                <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="p">[</span><span class="n">fosym_mf</span><span class="p">,</span> <span class="p">]))</span> \
                <span class="o">+</span> <span class="n">global_cit_diff_tangent_mf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">csct_matrix</span> <span class="o">=</span> \
                <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="p">[</span><span class="n">foid_mf</span><span class="p">,</span> <span class="p">]))</span> \
                <span class="o">+</span> <span class="n">global_cit_diff_tangent_mf</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Select clusters strain concentration tensors computation option:</span>
        <span class="c1">#</span>
        <span class="c1"># Option 1 - Solve linear system of equations</span>
        <span class="c1">#</span>
        <span class="c1"># Option 2 - Direct computation from inverse of equilibrium Jacobian</span>
        <span class="c1">#            matrix</span>
        <span class="c1">#</span>
        <span class="n">option</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">if</span> <span class="n">option</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Compute cluster strain concentration tensors system of linear</span>
            <span class="c1"># equations right-hand side</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
                <span class="n">csct_rhs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matlib</span><span class="o">.</span><span class="n">repmat</span><span class="p">(</span><span class="n">fosym_mf</span><span class="p">,</span> <span class="n">n_total_clusters</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">csct_rhs</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matlib</span><span class="o">.</span><span class="n">repmat</span><span class="p">(</span><span class="n">foid_mf</span><span class="p">,</span> <span class="n">n_total_clusters</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Initialize system solution matrix (containing clusters strain</span>
            <span class="c1"># concentration tensors)</span>
            <span class="n">global_csct_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">),</span>
                                       <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)))</span>
            <span class="c1"># Solve cluster strain concentration tensors system of linear</span>
            <span class="c1"># equations</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)):</span>
                <span class="n">global_csct_mf</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">csct_matrix</span><span class="p">,</span>
                                                          <span class="n">csct_rhs</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># Compute inverse of equilibrium jacobian matrix</span>
            <span class="n">csct_matrix_inv</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">csct_matrix</span><span class="p">)</span>
            <span class="c1"># Initialize system solution matrix (containing clusters strain</span>
            <span class="c1"># concentration tensors)</span>
            <span class="n">global_csct_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_total_clusters</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">),</span>
                                       <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)))</span>
            <span class="c1"># Initialize cluster indexes</span>
            <span class="n">i_init</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">i_end</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
            <span class="n">j_init</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">j_end</span> <span class="o">=</span> <span class="n">j_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
            <span class="c1"># Loop over material phases</span>
            <span class="k">for</span> <span class="n">mat_phase_I</span> <span class="ow">in</span> <span class="n">material_phases</span><span class="p">:</span>
                <span class="c1"># Loop over material phase clusters</span>
                <span class="k">for</span> <span class="n">cluster_I</span> <span class="ow">in</span> <span class="n">phase_clusters</span><span class="p">[</span><span class="n">mat_phase_I</span><span class="p">]:</span>
                    <span class="c1"># Loop over material phases</span>
                    <span class="k">for</span> <span class="n">mat_phase_J</span> <span class="ow">in</span> <span class="n">material_phases</span><span class="p">:</span>
                        <span class="c1"># Loop over material phase clusters</span>
                        <span class="k">for</span> <span class="n">cluster_J</span> <span class="ow">in</span> <span class="n">phase_clusters</span><span class="p">[</span><span class="n">mat_phase_J</span><span class="p">]:</span>
                            <span class="c1"># Add cluster J contribution to cluster I strain</span>
                            <span class="c1"># concentration tensor</span>
                            <span class="n">global_csct_mf</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> \
                                <span class="n">csct_matrix_inv</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">,</span> <span class="n">j_init</span><span class="p">:</span><span class="n">j_end</span><span class="p">]</span>
                            <span class="c1"># Increment cluster index</span>
                            <span class="n">j_init</span> <span class="o">=</span> <span class="n">j_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                            <span class="n">j_end</span> <span class="o">=</span> <span class="n">j_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                    <span class="c1"># Increment cluster indexes</span>
                    <span class="n">i_init</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                    <span class="n">i_end</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                    <span class="n">j_init</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">j_end</span> <span class="o">=</span> <span class="n">j_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Validate cluster strain concentration tensors computation</span>
        <span class="n">is_csct_validation</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">is_csct_validation</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_csct</span><span class="p">(</span><span class="n">material_phases</span><span class="p">,</span> <span class="n">phase_clusters</span><span class="p">,</span>
                                <span class="n">global_csct_mf</span><span class="p">,</span> <span class="n">global_strain_mf</span><span class="p">,</span>
                                <span class="n">farfield_strain_mf</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize effective tangent modulus</span>
        <span class="n">eff_tangent_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)))</span>
        <span class="c1"># Initialize clusters strain concentration tensors dictionary</span>
        <span class="n">clusters_sct_mf</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Initialize cluster index</span>
        <span class="n">i_init</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i_end</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># Loop over material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="n">material_phases</span><span class="p">:</span>
            <span class="c1"># Loop over material phase clusters</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">phase_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]:</span>
                <span class="c1"># Get material cluster volume fraction</span>
                <span class="n">cluster_vf</span> <span class="o">=</span> <span class="n">clusters_vf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>
                <span class="c1"># Get material cluster consistent tangent (matricial form)</span>
                <span class="n">cluster_tangent_mf</span> <span class="o">=</span> <span class="n">clusters_tangent_mf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>
                <span class="c1"># Get material cluster strain concentration tensor</span>
                <span class="n">cluster_sct_mf</span> <span class="o">=</span> <span class="n">global_csct_mf</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c1"># Store material cluster strain concentration tensor (matricial</span>
                <span class="c1"># form)</span>
                <span class="n">clusters_sct_mf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span> <span class="o">=</span> <span class="n">cluster_sct_mf</span>
                <span class="c1"># Add material cluster contribution to effective tangent</span>
                <span class="c1"># modulus</span>
                <span class="n">eff_tangent_mf</span> <span class="o">=</span> <span class="n">eff_tangent_mf</span> <span class="o">+</span> \
                    <span class="n">cluster_vf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">cluster_tangent_mf</span><span class="p">,</span> <span class="n">cluster_sct_mf</span><span class="p">)</span>
                <span class="c1"># Increment cluster index</span>
                <span class="n">i_init</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                <span class="n">i_end</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">eff_tangent_mf</span><span class="p">,</span> <span class="n">clusters_sct_mf</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._validate_csct"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._validate_csct">[docs]</a>    <span class="k">def</span> <span class="nf">_validate_csct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">material_phases</span><span class="p">,</span> <span class="n">phase_clusters</span><span class="p">,</span> <span class="n">global_csct_mf</span><span class="p">,</span>
                       <span class="n">global_strain_mf</span><span class="p">,</span> <span class="n">farfield_strain_mf</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validate clusters strain concentration tensors computation.</span>

<span class="sd">        This validation procedure requires the homogenized strain tensor</span>
<span class="sd">        instead of the far-field strain tensor in the SCA formulation without</span>
<span class="sd">        the far-field strain tensor.</span>

<span class="sd">        ----</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        material_phases : list[str]</span>
<span class="sd">            RVE material phases labels (str).</span>
<span class="sd">        phase_clusters : dict</span>
<span class="sd">            Clusters labels (item, list[int]) associated with each material</span>
<span class="sd">            phase (key, str).</span>
<span class="sd">        global_csct_mf : numpy.ndarray (2d)</span>
<span class="sd">            Global matrix of cluster strain concentration tensors (matricial</span>
<span class="sd">            form).</span>
<span class="sd">        global_strain_mf : numpy.ndarray (1d)</span>
<span class="sd">            Global vector of clusters strains stored in matricial form.</span>
<span class="sd">        farfield_strain_mf : numpy.ndarray (1d)</span>
<span class="sd">            Far-field strain tensor (matricial form).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set strain/stress components order according to problem strain</span>
        <span class="c1"># formulation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown problem strain formulation.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize cluster index</span>
        <span class="n">i_init</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i_end</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># Loop over material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="n">material_phases</span><span class="p">:</span>
            <span class="c1"># Loop over material phase clusters</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">phase_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]:</span>
                <span class="c1"># Get material cluster strain concentration tensor</span>
                <span class="n">cluster_sct_mf</span> <span class="o">=</span> <span class="n">global_csct_mf</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">,</span> <span class="p">:]</span>
                <span class="c1"># Compute cluster strain from strain concentration tensor</span>
                <span class="n">strain_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">cluster_sct_mf</span><span class="p">,</span> <span class="n">farfield_strain_mf</span><span class="p">)</span>
                <span class="c1"># Compare cluster strain computed from strain concentration</span>
                <span class="c1"># tensor with actual cluster strain. Raise error if equality</span>
                <span class="c1"># comparison fails</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">strain_mf</span><span class="p">,</span> <span class="n">global_strain_mf</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">],</span>
                                   <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-08</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Wrong computation of cluster strain &#39;</span>
                                       <span class="s1">&#39;concentration tensor.&#39;</span><span class="p">)</span>
                <span class="c1"># Increment cluster index</span>
                <span class="n">i_init</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                <span class="n">i_end</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._init_clusters_sct"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._init_clusters_sct">[docs]</a>    <span class="k">def</span> <span class="nf">_init_clusters_sct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">material_phases</span><span class="p">,</span> <span class="n">phase_clusters</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize cluster strain concentration tensors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        material_phases : list[str]</span>
<span class="sd">            RVE material phases labels (str).</span>
<span class="sd">        phase_clusters : dict</span>
<span class="sd">            Clusters labels (item, list[int]) associated with each material</span>
<span class="sd">            phase (key, str).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clusters_sct_mf : dict</span>
<span class="sd">            Fourth-order strain concentration tensor (matricial form)</span>
<span class="sd">            (item, numpy.ndarray (2d)) associated with each material cluster</span>
<span class="sd">            (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set strain/stress components order according to problem strain</span>
        <span class="c1"># formulation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown problem strain formulation.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize cluster strain concentration tensors dictionary</span>
        <span class="n">cluster_sct_mf</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Loop over material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="n">material_phases</span><span class="p">:</span>
            <span class="c1"># Loop over material phase clusters</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">phase_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]:</span>
                <span class="c1"># Initialize cluster strain concentration tensor (matricial</span>
                <span class="c1"># form)</span>
                <span class="n">cluster_sct_mf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">),</span>
                                                         <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">cluster_sct_mf</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._build_clusters_residuals"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._build_clusters_residuals">[docs]</a>    <span class="k">def</span> <span class="nf">_build_clusters_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">material_phases</span><span class="p">,</span> <span class="n">phase_clusters</span><span class="p">,</span>
                                  <span class="n">residual</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build clusters equilibrium residuals dictionary.</span>

<span class="sd">        This procedure is only carried out so that clusters equilibrium</span>
<span class="sd">        residuals are conveniently stored to perform post-processing</span>
<span class="sd">        operations.</span>

<span class="sd">        ----</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        material_phases : list[str]</span>
<span class="sd">            RVE material phases labels (str).</span>
<span class="sd">        phase_clusters : dict</span>
<span class="sd">            Clusters labels (item, list[int]) associated with each material</span>
<span class="sd">            phase (key, str).</span>
<span class="sd">        residual : numpy.ndarray (1d)</span>
<span class="sd">            Lippmann-Schwinger equilibrium residual vector.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clusters_residuals_mf : dict</span>
<span class="sd">            Equilibrium residual second-order tensor (matricial form)</span>
<span class="sd">            (item, numpy.ndarray (1d)) associated with each material cluster</span>
<span class="sd">            (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set strain/stress components order according to problem strain</span>
        <span class="c1"># formulation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown problem strain formulation.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize clusters equilibrium residuals dictionary</span>
        <span class="n">clusters_residuals_mf</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize cluster strain range indexes</span>
        <span class="n">i_init</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">i_end</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># Loop over material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="n">material_phases</span><span class="p">:</span>
            <span class="c1"># Loop over material phase clusters</span>
            <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">phase_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]:</span>
                <span class="c1"># Store cluster equilibrium residual</span>
                <span class="n">clusters_residuals_mf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span> <span class="o">=</span> <span class="n">residual</span><span class="p">[</span><span class="n">i_init</span><span class="p">:</span><span class="n">i_end</span><span class="p">]</span>
                <span class="c1"># Update cluster strain range indexes</span>
                <span class="n">i_init</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
                <span class="n">i_end</span> <span class="o">=</span> <span class="n">i_init</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">clusters_residuals_mf</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._display_inc_data"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._display_inc_data">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_display_inc_data</span><span class="p">(</span><span class="n">mac_load_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display loading increment data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mac_load_path : LoadingPath</span>
<span class="sd">            Macroscale loading path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get increment counter</span>
        <span class="n">inc</span> <span class="o">=</span> <span class="n">mac_load_path</span><span class="o">.</span><span class="n">get_increm_state</span><span class="p">()[</span><span class="s1">&#39;inc&#39;</span><span class="p">]</span>
        <span class="c1"># Get loading subpath data</span>
        <span class="n">sp_id</span><span class="p">,</span> <span class="n">sp_inc</span><span class="p">,</span> <span class="n">sp_total_lfact</span><span class="p">,</span> <span class="n">sp_inc_lfact</span><span class="p">,</span> <span class="n">sp_total_time</span><span class="p">,</span> \
            <span class="n">sp_inc_time</span><span class="p">,</span> <span class="n">subinc_level</span> <span class="o">=</span> <span class="n">mac_load_path</span><span class="o">.</span><span class="n">get_subpath_state</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Display loading increment data</span>
        <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;7&#39;</span><span class="p">,</span> <span class="s1">&#39;init&#39;</span><span class="p">,</span> <span class="n">inc</span><span class="p">,</span> <span class="n">subinc_level</span><span class="p">,</span> <span class="n">sp_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                         <span class="n">sp_total_lfact</span><span class="p">,</span> <span class="n">sp_total_time</span><span class="p">,</span> <span class="n">sp_inc</span><span class="p">,</span> <span class="n">sp_inc_lfact</span><span class="p">,</span>
                         <span class="n">sp_inc_time</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._display_scs_iter_data"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._display_scs_iter_data">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_display_scs_iter_data</span><span class="p">(</span><span class="n">ref_material</span><span class="p">,</span> <span class="n">is_lock_prop_ref</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;init&#39;</span><span class="p">,</span>
                               <span class="n">scs_iter_time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display reference material self-consistent scheme iteration data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ref_material : ElasticReferenceMaterial</span>
<span class="sd">            Elastic reference material.</span>
<span class="sd">        is_lock_prop_ref : bool</span>
<span class="sd">            True if elastic reference material properties are locked, False</span>
<span class="sd">            otherwise.</span>
<span class="sd">        mode : {&#39;init&#39;, &#39;end&#39;}</span>
<span class="sd">            Output mode: Self-consistent scheme iteration header (`init`) or</span>
<span class="sd">            footer (`end`).</span>
<span class="sd">        scs_iter_time : float</span>
<span class="sd">            Total self-consistent scheme time (s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get elastic reference material properties</span>
        <span class="n">material_properties</span> <span class="o">=</span> <span class="n">ref_material</span><span class="o">.</span><span class="n">get_material_properties</span><span class="p">()</span>
        <span class="c1"># Get self-consistent scheme iteration counter</span>
        <span class="n">scs_iter</span> <span class="o">=</span> <span class="n">ref_material</span><span class="o">.</span><span class="n">get_scs_iter</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Display reference material self-consistent scheme iteration data</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;end&#39;</span><span class="p">:</span>
            <span class="c1"># Display reference material self-consistent scheme iteration</span>
            <span class="c1"># footer</span>
            <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">scs_iter_time</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Display reference material self-consistent scheme iteration</span>
            <span class="c1"># header</span>
            <span class="k">if</span> <span class="n">is_lock_prop_ref</span><span class="p">:</span>
                <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;13&#39;</span><span class="p">,</span> <span class="s1">&#39;init&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">material_properties</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">],</span>
                                 <span class="n">material_properties</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">scs_iter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="s1">&#39;init&#39;</span><span class="p">,</span> <span class="n">scs_iter</span><span class="p">,</span>
                                     <span class="n">material_properties</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">],</span>
                                     <span class="n">material_properties</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Get normalized iterative changes of elastic reference</span>
                    <span class="c1"># material properties associated with the last</span>
                    <span class="c1"># self-consistent iteration convergence evaluation</span>
                    <span class="n">norm_dE</span> <span class="o">=</span> <span class="n">ref_material</span><span class="o">.</span><span class="n">get_norm_dE</span><span class="p">()</span>
                    <span class="n">norm_dv</span> <span class="o">=</span> <span class="n">ref_material</span><span class="o">.</span><span class="n">get_norm_dv</span><span class="p">()</span>
                    <span class="c1"># Display reference material self-consistent scheme</span>
                    <span class="c1"># iteration header</span>
                    <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;8&#39;</span><span class="p">,</span> <span class="s1">&#39;init&#39;</span><span class="p">,</span> <span class="n">scs_iter</span><span class="p">,</span>
                                     <span class="n">material_properties</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">],</span> <span class="n">norm_dE</span><span class="p">,</span>
                                     <span class="n">material_properties</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">],</span> <span class="n">norm_dv</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._display_nr_iter_data"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._display_nr_iter_data">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_display_nr_iter_data</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;init&#39;</span><span class="p">,</span> <span class="n">nr_iter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nr_iter_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                              <span class="n">errors</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display Newton-Raphson iteration data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : {&#39;init&#39;, &#39;iter&#39;}</span>
<span class="sd">            Output mode: Newton-Raphson iteration header (&#39;init&#39;) or solution</span>
<span class="sd">            related metrics (&#39;iter&#39;).</span>
<span class="sd">        nr_iter : int</span>
<span class="sd">            Newton-Raphson iteration counter.</span>
<span class="sd">        nr_iter_time : float</span>
<span class="sd">            Total Newton-Raphson iteration time (s).</span>
<span class="sd">        errors : list[float]</span>
<span class="sd">            List of errors associated with the Newton-Raphson convergence</span>
<span class="sd">            evaluation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;iter&#39;</span><span class="p">:</span>
            <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;9&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nr_iter</span><span class="p">,</span> <span class="n">nr_iter_time</span><span class="p">,</span> <span class="o">*</span><span class="n">errors</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;9&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ASCA._set_output_files"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ASCA.html#cratepy.online.crom.asca.ASCA._set_output_files">[docs]</a>    <span class="k">def</span> <span class="nf">_set_output_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">crve</span><span class="p">,</span> <span class="n">problem_name</span><span class="o">=</span><span class="s1">&#39;problem&#39;</span><span class="p">,</span>
                          <span class="n">is_clust_adapt_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">is_ref_material_output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_vtk_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">vtk_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_voxels_output</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create and initialize output files.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        output_dir : str</span>
<span class="sd">            Absolute directory path of output files.</span>
<span class="sd">        crve : CRVE</span>
<span class="sd">            Cluster-Reduced Representative Volume Element.</span>
<span class="sd">        problem_name : str, default=&#39;problem&#39;</span>
<span class="sd">            Problem name.</span>
<span class="sd">        is_clust_adapt_output : bool, default=False</span>
<span class="sd">            Clustering adaptivity output flag.</span>
<span class="sd">        is_ref_material_output : bool, default=False</span>
<span class="sd">            Reference material output flag.</span>
<span class="sd">        is_vtk_output : bool, default=False</span>
<span class="sd">            VTK output flag.</span>
<span class="sd">        vtk_data : dict, default=None</span>
<span class="sd">            VTK output file parameters.</span>
<span class="sd">        is_voxels_output : bool</span>
<span class="sd">            Voxels output flag.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hres_output : HomResOutput</span>
<span class="sd">            Output associated with the homogenized results.</span>
<span class="sd">        efftan_output : EffTanOutput</span>
<span class="sd">            Output associated with the CRVE effective tangent modulus.</span>
<span class="sd">        ref_mat_output : RefMatOutput</span>
<span class="sd">            Output associated with the reference material.</span>
<span class="sd">        voxels_output : VoxelsOutput</span>
<span class="sd">            Output associated with voxels material-related quantities.</span>
<span class="sd">        adapt_output : ClusteringAdaptivityOutput</span>
<span class="sd">            Output associated with the clustering adaptivity procedures.</span>
<span class="sd">        vtk_output : VTKOutput</span>
<span class="sd">            Output associated with the VTK files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">output_dir</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
            <span class="n">output_dir</span> <span class="o">+=</span> <span class="s1">&#39;/&#39;</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set file where homogenized strain/stress results are stored</span>
        <span class="n">hres_file_path</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="o">+</span> <span class="n">problem_name</span> <span class="o">+</span> <span class="s1">&#39;.hres&#39;</span>
        <span class="c1"># Instantiate homogenized results output</span>
        <span class="n">hres_output</span> <span class="o">=</span> <span class="n">HomResOutput</span><span class="p">(</span><span class="n">hres_file_path</span><span class="p">)</span>
        <span class="c1"># Write homogenized results output file header</span>
        <span class="n">hres_output</span><span class="o">.</span><span class="n">init_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set file where CRVE effective material tangent modulus is stored</span>
        <span class="n">efftan_file_path</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="o">+</span> <span class="n">problem_name</span> <span class="o">+</span> <span class="s1">&#39;.efftan&#39;</span>
        <span class="c1"># Instantiate CRVE effective material tangent modulus output</span>
        <span class="n">efftan_output</span> <span class="o">=</span> <span class="n">EffTanOutput</span><span class="p">(</span><span class="n">efftan_file_path</span><span class="p">)</span>
        <span class="c1"># Write homogenized results output file header</span>
        <span class="n">efftan_output</span><span class="o">.</span><span class="n">init_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="n">ref_mat_output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">is_ref_material_output</span><span class="p">:</span>
            <span class="c1"># Set file where reference material data is stored</span>
            <span class="n">refm_file_path</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="o">+</span> <span class="n">problem_name</span> <span class="o">+</span> <span class="s1">&#39;.refm&#39;</span>
            <span class="c1"># Instantiate reference material output</span>
            <span class="n">ref_mat_output</span> <span class="o">=</span> <span class="n">RefMatOutput</span><span class="p">(</span>
                <span class="n">refm_file_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_self_consistent_scheme</span><span class="p">)</span>
            <span class="c1"># Write reference material output file header</span>
            <span class="n">ref_mat_output</span><span class="o">.</span><span class="n">init_file</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="n">voxels_output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">is_voxels_output</span><span class="p">:</span>
            <span class="c1"># Set voxels material-related output file path</span>
            <span class="n">voxout_file_path</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="o">+</span> <span class="n">problem_name</span> <span class="o">+</span> <span class="s1">&#39;.voxout&#39;</span>
            <span class="c1"># Instantiate voxels material-related output</span>
            <span class="n">voxels_output</span> <span class="o">=</span> <span class="n">VoxelsOutput</span><span class="p">(</span>
                <span class="n">voxout_file_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">)</span>
            <span class="c1"># Write voxels material-related output file header</span>
            <span class="n">voxels_output</span><span class="o">.</span><span class="n">init_voxels_output_file</span><span class="p">(</span><span class="n">crve</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="n">vtk_output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">is_vtk_output</span><span class="p">:</span>
            <span class="c1"># Set VTK output directories paths</span>
            <span class="n">pvd_dir</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="o">+</span> <span class="s1">&#39;post_processing/&#39;</span>
            <span class="n">vtk_dir</span> <span class="o">=</span> <span class="n">pvd_dir</span> <span class="o">+</span> <span class="s1">&#39;VTK/&#39;</span>
            <span class="c1"># Instantiante VTK output</span>
            <span class="n">vtk_output</span> <span class="o">=</span> \
                <span class="n">VTKOutput</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ImageData&#39;</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;1.0&#39;</span><span class="p">,</span>
                          <span class="n">byte_order</span><span class="o">=</span><span class="n">vtk_data</span><span class="p">[</span><span class="s1">&#39;vtk_byte_order&#39;</span><span class="p">],</span>
                          <span class="nb">format</span><span class="o">=</span><span class="n">vtk_data</span><span class="p">[</span><span class="s1">&#39;vtk_format&#39;</span><span class="p">],</span>
                          <span class="n">precision</span><span class="o">=</span><span class="n">vtk_data</span><span class="p">[</span><span class="s1">&#39;vtk_precision&#39;</span><span class="p">],</span>
                          <span class="n">header_type</span><span class="o">=</span><span class="s1">&#39;UInt64&#39;</span><span class="p">,</span> <span class="n">base_name</span><span class="o">=</span><span class="n">problem_name</span><span class="p">,</span>
                          <span class="n">vtk_dir</span><span class="o">=</span><span class="n">vtk_dir</span><span class="p">,</span> <span class="n">pvd_dir</span><span class="o">=</span><span class="n">pvd_dir</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="n">adapt_output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">is_clust_adapt_output</span><span class="p">:</span>
            <span class="c1"># Set file where clustering adaptivity data is stored</span>
            <span class="n">adapt_file_path</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="o">+</span> <span class="n">problem_name</span> <span class="o">+</span> <span class="s1">&#39;.adapt&#39;</span>
            <span class="c1"># Instantiate clustering adaptivity output</span>
            <span class="n">adapt_output</span> <span class="o">=</span> <span class="n">ClusteringAdaptivityOutput</span><span class="p">(</span>
                <span class="n">adapt_file_path</span><span class="p">,</span> <span class="n">crve</span><span class="o">.</span><span class="n">get_adapt_material_phases</span><span class="p">())</span>
            <span class="c1"># Write clustering adaptivity output file header</span>
            <span class="n">adapt_output</span><span class="o">.</span><span class="n">init_adapt_file</span><span class="p">(</span><span class="n">crve</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">hres_output</span><span class="p">,</span> <span class="n">efftan_output</span><span class="p">,</span> <span class="n">ref_mat_output</span><span class="p">,</span> <span class="n">voxels_output</span><span class="p">,</span> \
            <span class="n">adapt_output</span><span class="p">,</span> <span class="n">vtk_output</span></div></div>
<span class="c1">#</span>
<span class="c1">#                                   Reference (fictitious) homogeneous material</span>
<span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="ElasticReferenceMaterial"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial">[docs]</a><span class="k">class</span> <span class="nc">ElasticReferenceMaterial</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Elastic reference material.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _n_dim : int</span>
<span class="sd">        Problem number of spatial dimensions.</span>
<span class="sd">    _comp_order_sym : list[str]</span>
<span class="sd">        Strain/Stress components symmetric order.</span>
<span class="sd">    _comp_order_nsym : list[str]</span>
<span class="sd">        Strain/Stress components nonsymmetric order.</span>
<span class="sd">    _material_properties : dict</span>
<span class="sd">        Elastic material properties (key, str) values</span>
<span class="sd">        (item, {int, float, bool}).</span>
<span class="sd">    _material_properties_old : dict</span>
<span class="sd">        Last loading increment converged elastic material properties (key, str)</span>
<span class="sd">        values (item, {int, float, bool}).</span>
<span class="sd">    _material_properties_init : dict</span>
<span class="sd">        Elastic material properties (key, str) values</span>
<span class="sd">        (item, {int, float, bool}) initial guess.</span>
<span class="sd">    _material_properties_scs_init : dict</span>
<span class="sd">        Elastic material properties (key, str) values</span>
<span class="sd">        (item, {int, float, bool}) converged in the first loading increment.</span>
<span class="sd">    _elastic_tangent_mf : numpy.ndarray (2d)</span>
<span class="sd">        Elastic tangent modulus in matricial form.</span>
<span class="sd">    _elastic_compliance_matrix : numpy.ndarray (2d)</span>
<span class="sd">        Elastic compliance in matrix form.</span>
<span class="sd">    _scs_iter : int</span>
<span class="sd">        Self-consistent scheme iteration counter.</span>
<span class="sd">    _norm_dE : float</span>
<span class="sd">        Normalized iterative change of Young modulus associated with the last</span>
<span class="sd">        self-consistent iteration convergence evaluation.</span>
<span class="sd">    _norm_dv : float</span>
<span class="sd">        Normalized iterative change of Poisson ratio associated with the last</span>
<span class="sd">        self-consistent iteration convergence evaluation.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    init_material_properties(self, material_phases, \</span>
<span class="sd">                             material_phases_properties, material_phases_vf, \</span>
<span class="sd">                             properties=None)</span>
<span class="sd">        Set initial guess of elastic reference material properties.</span>
<span class="sd">    update_material_properties(self, E, v)</span>
<span class="sd">        Update elastic reference material properties.</span>
<span class="sd">    update_converged_material_properties(self)</span>
<span class="sd">        Update converged elastic reference material properties.</span>
<span class="sd">    reset_material_properties(self)</span>
<span class="sd">        Reset material properties to last loading increment values.</span>
<span class="sd">    set_material_properties_scs_init(self)</span>
<span class="sd">        Set material properties converged in the first loading increment.</span>
<span class="sd">    get_material_properties(self)</span>
<span class="sd">        Get elastic reference material properties.</span>
<span class="sd">    get_elastic_tangent_mf(self)</span>
<span class="sd">        Get elastic tangent modulus in matricial form.</span>
<span class="sd">    get_elastic_compliance_matrix(self)</span>
<span class="sd">        Get elastic compliance in matrix form.</span>
<span class="sd">    init_scs_iter(self)</span>
<span class="sd">        Initialize self-consistent scheme iteration counter.</span>
<span class="sd">    update_scs_iter(self)</span>
<span class="sd">        Update self-consistent scheme iteration counter.</span>
<span class="sd">    get_scs_iter(self)</span>
<span class="sd">        Get self-consistent scheme iteration counter.</span>
<span class="sd">    get_norm_dE(self)</span>
<span class="sd">        Get normalized iterative change of Young modulus.</span>
<span class="sd">    get_norm_dv(self)</span>
<span class="sd">        Get normalized iterative change of Poisson ratio.</span>
<span class="sd">    self_consistent_update(self, strain_mf, strain_old_mf, stress_mf, \</span>
<span class="sd">                           stress_old_mf, eff_tangent_mf)</span>
<span class="sd">        Compute reference elastic properties through self-consistent scheme.</span>
<span class="sd">    _update_elastic_tangent(self)</span>
<span class="sd">        Update reference material elastic tangent modulus and compliance.</span>
<span class="sd">    _check_scs_solution(self, E, v)</span>
<span class="sd">        Check admissibility of self-consistent scheme iterative solution.</span>
<span class="sd">    check_scs_convergence(self, E, v)</span>
<span class="sd">        Check self-consistent scheme iterative solution convergence.</span>
<span class="sd">    get_available_scs(strain_formulation)</span>
<span class="sd">        Get available self-consistent schemes.</span>
<span class="sd">    lame_from_technical(E, v)</span>
<span class="sd">        Get Lamé parameters from Young modulus and Poisson ratio.</span>
<span class="sd">    technical_from_lame(lam, miu)</span>
<span class="sd">        Get Young modulus and Poisson ratio from Lamé parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.__init__"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span>
                 <span class="n">self_consistent_scheme</span><span class="p">,</span> <span class="n">conv_tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Problem strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        self_consistent_scheme : {&#39;regression&#39;,}, default=&#39;regression&#39;</span>
<span class="sd">            Self-consistent scheme to update the elastic reference material</span>
<span class="sd">            properties.</span>
<span class="sd">        conv_tol : float, default=1e-4</span>
<span class="sd">            Self-consistent scheme convergence tolerance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">=</span> <span class="n">strain_formulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span> <span class="o">=</span> <span class="n">problem_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_self_consistent_scheme</span> <span class="o">=</span> <span class="n">self_consistent_scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_conv_tol</span> <span class="o">=</span> <span class="n">conv_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_old</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_init</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_scs_init</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elastic_tangent_mf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scs_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elastic_compliance_matrix</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Get problem type parameters</span>
        <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">comp_order_nsym</span> <span class="o">=</span> \
            <span class="n">mop</span><span class="o">.</span><span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">=</span> <span class="n">n_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span> <span class="o">=</span> <span class="n">comp_order_sym</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span> <span class="o">=</span> <span class="n">comp_order_nsym</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.init_material_properties"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.init_material_properties">[docs]</a>    <span class="k">def</span> <span class="nf">init_material_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">material_phases</span><span class="p">,</span>
                                 <span class="n">material_phases_properties</span><span class="p">,</span>
                                 <span class="n">material_phases_vf</span><span class="p">,</span> <span class="n">properties</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set initial guess of elastic reference material properties.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        material_phases : list[str]</span>
<span class="sd">            RVE material phases labels (str).</span>
<span class="sd">        material_phases_properties : dict</span>
<span class="sd">            Constitutive model material properties (item, dict) associated with</span>
<span class="sd">            each material phase (key, str).</span>
<span class="sd">        material_phases_vf : dict</span>
<span class="sd">            Volume fraction (item, float) associated with each material phase</span>
<span class="sd">            (key, str).</span>
<span class="sd">        properties : dict, default=None</span>
<span class="sd">            Initial guess (item, float) of elastic reference material</span>
<span class="sd">            properties (key, str). Expecting Young&#39;s modulus (&#39;E&#39;) and</span>
<span class="sd">            Poisson&#39;s coefficient (&#39;v&#39;) for an isotropic elastic reference</span>
<span class="sd">            material.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">properties</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># If a initial guess of the elastic reference material properties</span>
            <span class="c1"># is not provided, set them from the volume average of the actual</span>
            <span class="c1"># material phases elastic properties</span>
            <span class="n">E</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">material_phases_vf</span><span class="p">[</span><span class="n">phase</span><span class="p">]</span>
                     <span class="o">*</span> <span class="n">material_phases_properties</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;E&#39;</span><span class="p">]</span>
                     <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="n">material_phases</span><span class="p">])</span>
            <span class="n">v</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">material_phases_vf</span><span class="p">[</span><span class="n">phase</span><span class="p">]</span>
                     <span class="o">*</span> <span class="n">material_phases_properties</span><span class="p">[</span><span class="n">phase</span><span class="p">][</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
                     <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="n">material_phases</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Set initial guess of elastic reference material properties</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize elastic reference material properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_init</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="n">E</span><span class="p">,</span> <span class="s1">&#39;v&#39;</span><span class="p">:</span> <span class="n">v</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties</span> <span class="o">=</span> \
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_init</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_old</span> <span class="o">=</span> \
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_init</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Update elastic tangent modulus and elastic compliance matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_elastic_tangent</span><span class="p">()</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.update_material_properties"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.update_material_properties">[docs]</a>    <span class="k">def</span> <span class="nf">update_material_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update elastic reference material properties.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E : float</span>
<span class="sd">            Young modulus of elastic reference material.</span>
<span class="sd">        v : float</span>
<span class="sd">            Poisson ratio of elastic reference material.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update elastic reference material properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">E</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Update elastic tangent modulus and elastic compliance matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_elastic_tangent</span><span class="p">()</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.update_converged_material_properties"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.update_converged_material_properties">[docs]</a>    <span class="k">def</span> <span class="nf">update_converged_material_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update converged elastic reference material properties.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_old</span> <span class="o">=</span> \
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_material_properties</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.reset_material_properties"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.reset_material_properties">[docs]</a>    <span class="k">def</span> <span class="nf">reset_material_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset material properties to last loading increment values.&quot;&quot;&quot;</span>
        <span class="c1"># Reset elastic reference material properties to last loading increment</span>
        <span class="c1"># values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties</span> <span class="o">=</span> \
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_old</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Update elastic tangent modulus and elastic compliance matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_elastic_tangent</span><span class="p">()</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.set_material_properties_scs_init"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.set_material_properties_scs_init">[docs]</a>    <span class="k">def</span> <span class="nf">set_material_properties_scs_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set material properties converged in the first loading increment.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_scs_init</span> <span class="o">=</span> \
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_material_properties</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.get_material_properties"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.get_material_properties">[docs]</a>    <span class="k">def</span> <span class="nf">get_material_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get elastic reference material properties.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        material_properties : dict</span>
<span class="sd">            Elastic material properties (key, str) values</span>
<span class="sd">            (item, {int, float, bool}).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_material_properties</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.get_elastic_tangent_mf"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.get_elastic_tangent_mf">[docs]</a>    <span class="k">def</span> <span class="nf">get_elastic_tangent_mf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get elastic tangent modulus in matricial form.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        elastic_tangent_mf : numpy.ndarray (2d)</span>
<span class="sd">            Elastic tangent modulus in matricial form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elastic_tangent_mf</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.get_elastic_compliance_matrix"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.get_elastic_compliance_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_elastic_compliance_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get elastic compliance in matrix form.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        elastic_compliance_matrix : numpy.ndarray (2d)</span>
<span class="sd">            Elastic compliance in matrix form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elastic_compliance_matrix</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.init_scs_iter"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.init_scs_iter">[docs]</a>    <span class="k">def</span> <span class="nf">init_scs_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize self-consistent scheme iteration counter.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scs_iter</span> <span class="o">=</span> <span class="mi">0</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.update_scs_iter"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.update_scs_iter">[docs]</a>    <span class="k">def</span> <span class="nf">update_scs_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update self-consistent scheme iteration counter.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scs_iter</span> <span class="o">+=</span> <span class="mi">1</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.get_scs_iter"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.get_scs_iter">[docs]</a>    <span class="k">def</span> <span class="nf">get_scs_iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get self-consistent scheme iteration counter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scs_iter : int</span>
<span class="sd">            Self-consistent scheme iteration counter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scs_iter</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.get_norm_dE"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.get_norm_dE">[docs]</a>    <span class="k">def</span> <span class="nf">get_norm_dE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get normalized iterative change of Young modulus.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm_dE : float</span>
<span class="sd">            Normalized iterative change of Young modulus associated with the</span>
<span class="sd">            last self-consistent iteration convergence evaluation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norm_dE</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.get_norm_dv"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.get_norm_dv">[docs]</a>    <span class="k">def</span> <span class="nf">get_norm_dv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get normalized iterative change of Poisson ratio.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        norm_dv : float</span>
<span class="sd">            Normalized iterative change of Poisson ratio associated with the</span>
<span class="sd">            last self-consistent iteration convergence evaluation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norm_dv</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.self_consistent_update"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.self_consistent_update">[docs]</a>    <span class="k">def</span> <span class="nf">self_consistent_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strain_mf</span><span class="p">,</span> <span class="n">strain_old_mf</span><span class="p">,</span> <span class="n">stress_mf</span><span class="p">,</span>
                               <span class="n">stress_old_mf</span><span class="p">,</span> <span class="n">eff_tangent_mf</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute reference elastic properties through self-consistent scheme.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain_mf : numpy.ndarray (1d)</span>
<span class="sd">            Homogenized strain (matricial form): infinitesimal strain tensor</span>
<span class="sd">            (infinitesimal strains) or deformation gradient (finite strains)</span>
<span class="sd">        strain_old_mf : numpy.ndarray (1d)</span>
<span class="sd">            Last converged homogenized strain (matricial form): infinitesimal</span>
<span class="sd">            strain tensor (infinitesimal strains) or deformation gradient</span>
<span class="sd">            (finite strains)</span>
<span class="sd">        stress_mf : numpy.ndarray (1d)</span>
<span class="sd">            Homogenized stress (matricial form): Cauchy stress tensor</span>
<span class="sd">            (infinitesimal strains) or first Piola-Kirchhoff stress tensor</span>
<span class="sd">            (finite strains).</span>
<span class="sd">        stress_old_mf : numpy.ndarray (1d)</span>
<span class="sd">            Last converged homogenized stress (matricial form): Cauchy stress</span>
<span class="sd">            tensor (infinitesimal strains) or first Piola-Kirchhoff stress</span>
<span class="sd">            tensor (finite strains).</span>
<span class="sd">        eff_tangent_mf : numpy.ndarray (2d)</span>
<span class="sd">            CRVE effective material tangent modulus (matricial form).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_admissible : bool</span>
<span class="sd">            True if self-consistent scheme iterative solution is admissible,</span>
<span class="sd">            False otherwise.</span>
<span class="sd">        E : float</span>
<span class="sd">            Young modulus of elastic reference material.</span>
<span class="sd">        v : float</span>
<span class="sd">            Poisson ratio of elastic reference material.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute incremental homogenized strain and stress tensors according</span>
        <span class="c1"># to problem strain formulation and self-consistent scheme</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="c1"># Compute incremental homogenized infinitesimal strain tensor</span>
            <span class="n">inc_strain_mf</span> <span class="o">=</span> <span class="n">strain_mf</span> <span class="o">-</span> <span class="n">strain_old_mf</span>
            <span class="c1"># Compute incremental homogenized Cauchy stress tensor</span>
            <span class="n">inc_stress_mf</span> <span class="o">=</span> <span class="n">stress_mf</span> <span class="o">-</span> <span class="n">stress_old_mf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;A suitable self-consistent scheme has not &#39;</span>
                               <span class="s1">&#39;been developed under finite strains yet.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute elastic reference material properties based on the</span>
        <span class="c1"># regression-based self-consistent scheme</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_self_consistent_scheme</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;regression&#39;</span><span class="p">,):</span>
            <span class="c1"># Initialize elastic reference material properties regression-based</span>
            <span class="c1"># self-consistent scheme optimizer</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
                <span class="c1"># Initialize elastic reference material properties optimizer</span>
                <span class="n">ref_optimizer</span> <span class="o">=</span> <span class="n">InfinitesimalRegressionSCS</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_old</span><span class="p">),</span>
                    <span class="n">inc_strain_mf</span><span class="p">,</span> <span class="n">inc_stress_mf</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute elastic reference material properties</span>
        <span class="n">E</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">ref_optimizer</span><span class="o">.</span><span class="n">compute_reference_properties</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Check admissibility of self-consistent scheme solution</span>
        <span class="n">is_admissible</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_scs_solution</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">is_admissible</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">v</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial._update_elastic_tangent"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial._update_elastic_tangent">[docs]</a>    <span class="k">def</span> <span class="nf">_update_elastic_tangent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update reference material elastic tangent modulus and compliance.</span>

<span class="sd">        *Infinitesimal strains:*</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\boldsymbol{\\mathsf{D}}^{e,\\,0} = \\lambda^{0} \\boldsymbol{I}</span>
<span class="sd">           \\otimes \\boldsymbol{I} + 2 \\mu^{0}  \\boldsymbol{\\mathsf{I}}_{s}</span>
<span class="sd">           \\, ,</span>

<span class="sd">        where :math:`\\boldsymbol{\\mathsf{D}}^{e,\\,0}` is the reference</span>
<span class="sd">        material elastic tangent modulus, :math:`\\lambda^{0}` and</span>
<span class="sd">        :math:`\\mu^{0}` are the elastic Lamé parameters,</span>
<span class="sd">        :math:`\\boldsymbol{I}` is the second-order identity tensor, and</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{I}}_{s}` is the fourth-order symmetric</span>
<span class="sd">        identity tensor.</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\boldsymbol{\\mathsf{S}}^{e,\\,0} =</span>
<span class="sd">           - \\dfrac{\\lambda^{0}}{2 \\mu^{0} (3\\lambda^{0} + 2\\mu^{0})}</span>
<span class="sd">           \\boldsymbol{I} \\otimes \\boldsymbol{I} +</span>
<span class="sd">           \\dfrac{1}{2 \\mu^{0}}  \\boldsymbol{\\mathsf{I}}_{s} \\, ,</span>

<span class="sd">        where :math:`\\boldsymbol{\\mathsf{S}}^{e,\\,0}` is the reference</span>
<span class="sd">        material elastic compliance, :math:`\\lambda^{0}` and :math:`\\mu^{0}`</span>
<span class="sd">        are the elastic Lamé parameters, :math:`\\boldsymbol{I}` is the</span>
<span class="sd">        second-order identity tensor, and :math:`\\boldsymbol{\\mathsf{I}}_{s}`</span>
<span class="sd">        is the fourth-order symmetric identity tensor.</span>

<span class="sd">        ----</span>

<span class="sd">        *Finite strains:*</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\boldsymbol{\\mathsf{A}}^{e,\\,0} = \\lambda^{0} \\boldsymbol{I}</span>
<span class="sd">           \\otimes \\boldsymbol{I} + 2 \\mu^{0}  \\boldsymbol{\\mathsf{I}}</span>
<span class="sd">           \\, ,</span>

<span class="sd">        where :math:`\\boldsymbol{\\mathsf{A}}^{e,\\,0}` is the reference</span>
<span class="sd">        material hyperelastic tangent modulus, :math:`\\lambda^{0}` and</span>
<span class="sd">        :math:`\\mu^{0}` are the elastic Lamé parameters,</span>
<span class="sd">        :math:`\\boldsymbol{I}` is the second-order identity tensor, and</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{I}}` is the fourth-order identity tensor.</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\boldsymbol{\\mathsf{S}}^{e,\\,0} =</span>
<span class="sd">           - \\dfrac{\\lambda^{0}}{2 \\mu^{0} (3\\lambda^{0} + 2\\mu^{0})}</span>
<span class="sd">           \\boldsymbol{I} \\otimes \\boldsymbol{I} +</span>
<span class="sd">           \\dfrac{1}{2 \\mu^{0}}  \\boldsymbol{\\mathsf{I}} \\, ,</span>

<span class="sd">        where :math:`\\boldsymbol{\\mathsf{S}}^{e,\\,0}` is the reference</span>
<span class="sd">        material hyperelastic compliance, :math:`\\lambda^{0}` and</span>
<span class="sd">        :math:`\\mu^{0}` are the elastic Lamé parameters,</span>
<span class="sd">        :math:`\\boldsymbol{I}` is the second-order identity tensor, and</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{I}}` is the fourth-order symmetric</span>
<span class="sd">        identity tensor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get Young&#39;s Modulus and Poisson&#39;s ratio</span>
        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span>
        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute Lamé parameters</span>
        <span class="n">lam</span><span class="p">,</span> <span class="n">miu</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">lame_from_technical</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set required fourth-order tensors</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">foid</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">fosym</span><span class="p">,</span> <span class="n">fodiagtrace</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
            <span class="n">top</span><span class="o">.</span><span class="n">get_id_operators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute elastic tangent modulus and elastic compliance matrix</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="c1"># Set symmetric strain/stress component order</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span>
            <span class="c1"># Compute elastic tangent modulus and elastic compliance matrix</span>
            <span class="c1"># according to problem type</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
                <span class="c1"># Compute elastic tangent modulus</span>
                <span class="n">elastic_tangent</span> <span class="o">=</span> <span class="n">lam</span><span class="o">*</span><span class="n">fodiagtrace</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">miu</span><span class="o">*</span><span class="n">fosym</span>
                <span class="c1"># Compute elastic compliance</span>
                <span class="n">elastic_compliance</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">lam</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">miu</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">lam</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">miu</span><span class="p">)))</span> \
                    <span class="o">*</span> <span class="n">fodiagtrace</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">miu</span><span class="p">))</span><span class="o">*</span><span class="n">fosym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Set nonsymmetric strain/stress component order</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span>
            <span class="c1"># Compute elastic tangent modulus and elastic compliance matrix</span>
            <span class="c1"># according to problem type</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
                <span class="c1"># Compute elastic tangent modulus (2D problem (plane strain),</span>
                <span class="c1"># 3D problem)</span>
                <span class="n">elastic_tangent</span> <span class="o">=</span> <span class="n">lam</span><span class="o">*</span><span class="n">fodiagtrace</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">miu</span><span class="o">*</span><span class="n">foid</span>
                <span class="c1"># Compute elastic compliance</span>
                <span class="n">elastic_compliance</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">lam</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">miu</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">lam</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">miu</span><span class="p">)))</span> \
                    <span class="o">*</span> <span class="n">fodiagtrace</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">miu</span><span class="p">))</span><span class="o">*</span><span class="n">foid</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build elastic tangent modulus matricial form</span>
        <span class="n">elastic_tangent_mf</span> <span class="o">=</span> <span class="n">mop</span><span class="o">.</span><span class="n">get_tensor_mf</span><span class="p">(</span><span class="n">elastic_tangent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span>
                                               <span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># Build elastic compliance matricial form</span>
        <span class="n">elastic_compliance_mf</span> <span class="o">=</span> <span class="n">mop</span><span class="o">.</span><span class="n">get_tensor_mf</span><span class="p">(</span><span class="n">elastic_compliance</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># Build elastic compliance matrix (without matricial form associated</span>
        <span class="c1"># coefficients)</span>
        <span class="n">elastic_compliance_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">elastic_compliance_mf</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)):</span>
                <span class="n">elastic_compliance_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">mop</span><span class="o">.</span><span class="n">kelvin_factor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">))</span> \
                    <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">mop</span><span class="o">.</span><span class="n">kelvin_factor</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">))</span> \
                    <span class="o">*</span> <span class="n">elastic_compliance_mf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Update reference material elastic tangent modulus and compliance</span>
        <span class="c1"># matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elastic_tangent_mf</span> <span class="o">=</span> <span class="n">elastic_tangent_mf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elastic_compliance_matrix</span> <span class="o">=</span> <span class="n">elastic_compliance_matrix</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial._check_scs_solution"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial._check_scs_solution">[docs]</a>    <span class="k">def</span> <span class="nf">_check_scs_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check admissibility of self-consistent scheme iterative solution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E : float</span>
<span class="sd">            Young modulus of elastic reference material.</span>
<span class="sd">        v : float</span>
<span class="sd">            Poisson ratio of elastic reference material.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_admissible : bool</span>
<span class="sd">            True if self-consistent scheme iterative solution is admissible,</span>
<span class="sd">            False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set admissibility default value</span>
        <span class="n">is_admissible</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Evaluate admissibility conditions:</span>
        <span class="c1"># Reference material Young modulus</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_init</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">condition_1</span> <span class="o">=</span> <span class="n">E</span> <span class="o">&gt;</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">condition_1</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_init</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mf">0.01</span>
        <span class="c1"># Reference material Poisson ratio</span>
        <span class="n">condition_2</span> <span class="o">=</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span><span class="o">/</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set admissibility of self-consistent scheme iterative solution</span>
        <span class="n">is_admissible</span> <span class="o">=</span> <span class="n">condition_1</span> <span class="ow">and</span> <span class="n">condition_2</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">is_admissible</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.check_scs_convergence"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.check_scs_convergence">[docs]</a>    <span class="k">def</span> <span class="nf">check_scs_convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check self-consistent scheme iterative solution convergence.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E : float</span>
<span class="sd">            Young modulus of elastic reference material.</span>
<span class="sd">        v : float</span>
<span class="sd">            Poisson ratio of elastic reference material.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_converged : bool</span>
<span class="sd">            True if self-consistent scheme iterative solution converged, False</span>
<span class="sd">            otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute iterative variation of the reference material Young modulus</span>
        <span class="c1"># and Poisson ratio</span>
        <span class="n">dE</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute normalized iterative change of the reference material Young</span>
        <span class="c1"># modulus and Poisson ratio</span>
        <span class="n">norm_dE</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dE</span><span class="o">/</span><span class="n">E</span><span class="p">)</span>
        <span class="n">norm_dv</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dv</span><span class="o">/</span><span class="n">v</span><span class="p">)</span>
        <span class="c1"># Store normalized iterative change of reference material properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_norm_dE</span> <span class="o">=</span> <span class="n">norm_dE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_norm_dv</span> <span class="o">=</span> <span class="n">norm_dv</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Check self-consistent scheme convergence</span>
        <span class="n">is_converged</span> <span class="o">=</span> <span class="p">(</span><span class="n">norm_dE</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_tol</span><span class="p">)</span> \
            <span class="ow">and</span> <span class="p">(</span><span class="n">norm_dv</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conv_tol</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">is_converged</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.get_available_scs"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.get_available_scs">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_available_scs</span><span class="p">(</span><span class="n">strain_formulation</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get available self-consistent schemes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Problem strain formulation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        available_scs : tuple[str]</span>
<span class="sd">            Available self-consistent schemes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">available_scs</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="s1">&#39;regression&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="n">available_scs</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown problem strain formulation.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">available_scs</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.lame_from_technical"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.lame_from_technical">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">lame_from_technical</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get Lamé parameters from Young modulus and Poisson ratio.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E : float</span>
<span class="sd">            Young modulus.</span>
<span class="sd">        v : float</span>
<span class="sd">            Poisson ratio.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lam : float</span>
<span class="sd">            Lamé parameter.</span>
<span class="sd">        miu : float</span>
<span class="sd">            Lamé parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute Lamé parameters</span>
        <span class="n">lam</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">v</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">v</span><span class="p">))</span>
        <span class="n">miu</span> <span class="o">=</span> <span class="n">E</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">v</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">lam</span><span class="p">,</span> <span class="n">miu</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ElasticReferenceMaterial.technical_from_lame"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ElasticReferenceMaterial.html#cratepy.online.crom.asca.ElasticReferenceMaterial.technical_from_lame">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">technical_from_lame</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">miu</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get Young modulus and Poisson ratio from Lamé parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lam : float</span>
<span class="sd">            Lamé parameter.</span>
<span class="sd">        miu : float</span>
<span class="sd">            Lamé parameter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        E : float</span>
<span class="sd">            Young modulus.</span>
<span class="sd">        v : float</span>
<span class="sd">            Poisson ratio.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute Young modulus and Poisson ratio</span>
        <span class="n">E</span> <span class="o">=</span> <span class="p">(</span><span class="n">miu</span><span class="o">*</span><span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">lam</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">miu</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">lam</span> <span class="o">+</span> <span class="n">miu</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">lam</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="n">lam</span> <span class="o">+</span> <span class="n">miu</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">E</span><span class="p">,</span> <span class="n">v</span></div></div>
<span class="c1">#</span>
<span class="c1">#                            Interface: Reference material properties optimizer</span>
<span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="ReferenceMaterialOptimizer"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ReferenceMaterialOptimizer.html#cratepy.online.crom.asca.ReferenceMaterialOptimizer">[docs]</a><span class="k">class</span> <span class="nc">ReferenceMaterialOptimizer</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Elastic reference material properties optimizer interface.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _n_dim : int</span>
<span class="sd">        Problem number of spatial dimensions.</span>
<span class="sd">    _comp_order_sym : list[str]</span>
<span class="sd">        Strain/Stress components symmetric order.</span>
<span class="sd">    _comp_order_nsym : list[str]</span>
<span class="sd">        Strain/Stress components nonsymmetric order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ReferenceMaterialOptimizer.__init__"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ReferenceMaterialOptimizer.html#cratepy.online.crom.asca.ReferenceMaterialOptimizer.__init__">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Elastic reference material properties optimizer constructor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Problem strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="ReferenceMaterialOptimizer.compute_reference_properties"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.ReferenceMaterialOptimizer.html#cratepy.online.crom.asca.ReferenceMaterialOptimizer.compute_reference_properties">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">compute_reference_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute elastic reference material properties.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        young : float</span>
<span class="sd">            Young modulus of elastic reference material.</span>
<span class="sd">        poiss : float</span>
<span class="sd">            Poisson ratio of elastic reference material.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>
<span class="c1">#</span>
<span class="c1">#                                      Reference material properties optimizers</span>
<span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="InfinitesimalRegressionSCS"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.InfinitesimalRegressionSCS.html#cratepy.online.crom.asca.InfinitesimalRegressionSCS">[docs]</a><span class="k">class</span> <span class="nc">InfinitesimalRegressionSCS</span><span class="p">(</span><span class="n">ReferenceMaterialOptimizer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Infinitesimal strains format regression-based self-consistent scheme.</span>

<span class="sd">    *Mimization problem:*</span>

<span class="sd">    .. math::</span>

<span class="sd">       \\left\\{ \\lambda^{0}_{n+1}, \\, \\mu^{0}_{n+1} \\right\\} =</span>
<span class="sd">       \\underset{ \\left\\{ \\lambda &#39;, \\, \\, \\mu &#39; \\right\\} }{</span>
<span class="sd">       \\mathrm{argmin}} \\,  || \\Delta \\boldsymbol{\\sigma}_{n+1} -</span>
<span class="sd">       \\boldsymbol{\\mathsf{D}}^{e, \\, 0}_{n+1}(\\lambda &#39;,\\mu &#39;) :</span>
<span class="sd">       \\Delta \\boldsymbol{\\varepsilon}_{n+1} ||^{2}</span>

<span class="sd">    where :math:`\\lambda^{0}` and :math:`\\mu^{0}` are the elastic Lamé</span>
<span class="sd">    parameters, :math:`\\Delta \\boldsymbol{\\sigma}` is the homogenized</span>
<span class="sd">    incremental Cauchy stress tensor,</span>
<span class="sd">    :math:`\\boldsymbol{\\mathsf{D}}^{e,\\,0}` is the reference material</span>
<span class="sd">    elastic tangent modulus, :math:`\\Delta \\boldsymbol{\\varepsilon}` is</span>
<span class="sd">    the homogenized incremental infinitesimal strain tensor, and</span>
<span class="sd">    :math:`n+1` denotes the current increment.</span>

<span class="sd">    ----</span>

<span class="sd">    *Solution:*</span>

<span class="sd">    .. math::</span>

<span class="sd">        \\begin{bmatrix}</span>
<span class="sd">                \\lambda^{0}_{m+1} \\\\[10pt] \\mu^{0}_{m+1}</span>
<span class="sd">            \\end{bmatrix}</span>
<span class="sd">            =</span>
<span class="sd">            \\begin{bmatrix}</span>
<span class="sd">                \\text{tr} \\, \\left[ \\boldsymbol{I} \\right] \\,</span>
<span class="sd">                \\text{tr} \\, \\left[ \\Delta</span>
<span class="sd">                \\boldsymbol{\\varepsilon}_{m+1} \\right] &amp; 2 \\,</span>
<span class="sd">                \\text{tr} \\, \\left[ \\Delta</span>
<span class="sd">                \\boldsymbol{\\varepsilon}_{m+1} \\right] \\\\[10pt]</span>
<span class="sd">                 \\text{tr} \\, \\left[ \\Delta</span>
<span class="sd">                 \\boldsymbol{\\varepsilon}_{m+1} \\right]^{2} &amp; 2</span>
<span class="sd">                 \\Delta \\boldsymbol{\\varepsilon}_{m+1} :</span>
<span class="sd">                 \\Delta \\boldsymbol{\\varepsilon}_{m+1}</span>
<span class="sd">            \\end{bmatrix}^{-1}</span>
<span class="sd">            \\begin{bmatrix}</span>
<span class="sd">                 \\,  \\text{tr} \\, \\left[ \\Delta</span>
<span class="sd">                 \\boldsymbol{\\sigma}_{m+1} \\right] \\\\[10pt]</span>
<span class="sd">                 \\Delta \\boldsymbol{\\sigma}_{m+1}: \\Delta</span>
<span class="sd">                 \\boldsymbol{\\varepsilon}_{m+1}</span>
<span class="sd">            \\end{bmatrix} \\, .</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _n_dim : int</span>
<span class="sd">        Problem number of spatial dimensions.</span>
<span class="sd">    _comp_order_sym : list[str]</span>
<span class="sd">        Strain/Stress components symmetric order.</span>
<span class="sd">    _comp_order_nsym : list[str]</span>
<span class="sd">        Strain/Stress components nonsymmetric order.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="InfinitesimalRegressionSCS.__init__"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.InfinitesimalRegressionSCS.html#cratepy.online.crom.asca.InfinitesimalRegressionSCS.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span>
                 <span class="n">material_properties_old</span><span class="p">,</span> <span class="n">inc_strain_mf</span><span class="p">,</span> <span class="n">inc_stress_mf</span><span class="p">,</span>
                 <span class="n">is_symmetrized</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Problem strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        material_properties_old : dict</span>
<span class="sd">            Last loading increment converged elastic reference material</span>
<span class="sd">            properties (key, str) values (item, {int, float, bool}).</span>
<span class="sd">        inc_strain_mf : numpy.ndarray (1d)</span>
<span class="sd">            Incremental homogenized strain (matricial form).</span>
<span class="sd">        inc_stress_mf : numpy.ndarray (1d)</span>
<span class="sd">            Incremental homogenized stress (matricial form).</span>
<span class="sd">        is_symmetrized : bool, default=False</span>
<span class="sd">            True if a symmetric alternative stress-strain conjugate pair is</span>
<span class="sd">            adopted in the finite strains regression-based self-consistent</span>
<span class="sd">            scheme, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">=</span> <span class="n">strain_formulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span> <span class="o">=</span> <span class="n">problem_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_old</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">material_properties_old</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inc_strain_mf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">inc_strain_mf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inc_stress_mf</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">inc_stress_mf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_symmetrized</span> <span class="o">=</span> <span class="n">is_symmetrized</span>
        <span class="c1"># Get problem type parameters</span>
        <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">comp_order_nsym</span> <span class="o">=</span> \
            <span class="n">mop</span><span class="o">.</span><span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">=</span> <span class="n">n_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span> <span class="o">=</span> <span class="n">comp_order_sym</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span> <span class="o">=</span> <span class="n">comp_order_nsym</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="InfinitesimalRegressionSCS.compute_reference_properties"><a class="viewcode-back" href="../../../../_autosummary/cratepy.online.crom.asca.InfinitesimalRegressionSCS.html#cratepy.online.crom.asca.InfinitesimalRegressionSCS.compute_reference_properties">[docs]</a>    <span class="k">def</span> <span class="nf">compute_reference_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute elastic reference material properties.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        E : float</span>
<span class="sd">            Young modulus of elastic reference material.</span>
<span class="sd">        v : float</span>
<span class="sd">            Poisson ratio of elastic reference material.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set strain/stress components order</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_symmetrized</span><span class="p">:</span>
                <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown problem strain formulation.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inc_strain_mf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inc_strain_mf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]):</span>
            <span class="c1"># Get last loading increment converged elastic reference material</span>
            <span class="c1"># properties</span>
            <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_old</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_old</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
            <span class="c1"># Return</span>
            <span class="k">return</span> <span class="n">E</span><span class="p">,</span> <span class="n">v</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Set second-order identity tensor</span>
        <span class="n">soid</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">get_id_operators</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize self-consistent scheme system of linear equations</span>
        <span class="c1"># coefficient matrix and right-hand side</span>
        <span class="n">scs_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">scs_rhs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Get incremental strain and stress tensors</span>
        <span class="n">inc_strain</span> <span class="o">=</span> <span class="n">mop</span><span class="o">.</span><span class="n">get_tensor_from_mf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inc_strain_mf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span>
                                            <span class="n">comp_order</span><span class="p">)</span>
        <span class="n">inc_stress</span> <span class="o">=</span> <span class="n">mop</span><span class="o">.</span><span class="n">get_tensor_from_mf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_inc_stress_mf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">,</span>
                                            <span class="n">comp_order</span><span class="p">)</span>
        <span class="c1"># Compute self-consistent scheme system of linear equations right-hand</span>
        <span class="c1"># side</span>
        <span class="n">scs_rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">inc_stress</span><span class="p">)</span>
        <span class="n">scs_rhs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">ddot22_1</span><span class="p">(</span><span class="n">inc_stress</span><span class="p">,</span> <span class="n">inc_strain</span><span class="p">)</span>
        <span class="c1"># Compute self-consistent scheme system of linear equations coefficient</span>
        <span class="c1"># matrix</span>
        <span class="n">scs_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">inc_strain</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">soid</span><span class="p">)</span>
        <span class="n">scs_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">inc_strain</span><span class="p">)</span>
        <span class="n">scs_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">inc_strain</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">scs_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">top</span><span class="o">.</span><span class="n">ddot22_1</span><span class="p">(</span><span class="n">inc_strain</span><span class="p">,</span> <span class="n">inc_strain</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Limitation 1: Under isochoric loading conditions the first equation</span>
        <span class="c1"># of the self-consistent scheme system of linear equations vanishes</span>
        <span class="c1"># (derivative with respect to lambda). In this case, adopt the previous</span>
        <span class="c1"># converged lambda and compute miu from the second equation of the</span>
        <span class="c1"># self-consistent scheme system of linear equations</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">inc_strain</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">inc_strain</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-10</span> \
                <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">scs_matrix</span><span class="p">,</span> <span class="n">scs_rhs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Get previous converged reference material elastic properties</span>
            <span class="n">E_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_old</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span>
            <span class="n">v_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_old</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
            <span class="c1"># Compute previous converged lambda</span>
            <span class="n">lam</span> <span class="o">=</span> <span class="p">(</span><span class="n">E_old</span><span class="o">*</span><span class="n">v_old</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">v_old</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">v_old</span><span class="p">))</span>
            <span class="c1"># Compute miu</span>
            <span class="n">miu</span> <span class="o">=</span> <span class="n">scs_rhs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">scs_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Limitation 2: Under hydrostatic loading conditions both equations of</span>
        <span class="c1"># the self-consistent scheme system of linear equations become linearly</span>
        <span class="c1"># dependent. In this case, assume that the ratio between lambda and miu</span>
        <span class="c1"># is the same as in the previous converged values and solve the first</span>
        <span class="c1"># equation of self-consistent scheme system of linear equations</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">inc_strain</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">inc_strain</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                     <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">inc_strain</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span><span class="p">)])</span> <span class="ow">and</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">inc_strain</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">inc_strain</span><span class="p">)),</span>
                            <span class="n">atol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
            <span class="c1"># Get previous converged reference material elastic properties</span>
            <span class="n">E_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_old</span><span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">]</span>
            <span class="n">v_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_properties_old</span><span class="p">[</span><span class="s1">&#39;v&#39;</span><span class="p">]</span>
            <span class="c1"># Compute previous converged reference material Lamé parameters</span>
            <span class="n">lam_old</span> <span class="o">=</span> <span class="p">(</span><span class="n">E_old</span><span class="o">*</span><span class="n">v_old</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">v_old</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">v_old</span><span class="p">))</span>
            <span class="n">miu_old</span> <span class="o">=</span> <span class="n">E_old</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">v_old</span><span class="p">))</span>
            <span class="c1"># Compute reference material Lamé parameters</span>
            <span class="n">lam</span> <span class="o">=</span> <span class="p">(</span><span class="n">scs_rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">scs_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">lam_old</span><span class="o">/</span><span class="p">(</span><span class="n">lam_old</span> <span class="o">+</span> <span class="n">miu_old</span><span class="p">))</span>
            <span class="n">miu</span> <span class="o">=</span> <span class="p">(</span><span class="n">scs_rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">scs_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">miu_old</span><span class="o">/</span><span class="p">(</span><span class="n">lam_old</span> <span class="o">+</span> <span class="n">miu_old</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Solve self-consistent scheme system of linear equations</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scs_solution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">scs_matrix</span><span class="p">,</span> <span class="n">scs_rhs</span><span class="p">)</span>
            <span class="c1"># Get reference material Lamé parameters</span>
            <span class="n">lam</span> <span class="o">=</span> <span class="n">scs_solution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">miu</span> <span class="o">=</span> <span class="n">scs_solution</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute reference material Young modulus and Poisson ratio</span>
        <span class="n">E</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">ElasticReferenceMaterial</span><span class="o">.</span><span class="n">technical_from_lame</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="n">miu</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">E</span><span class="p">,</span> <span class="n">v</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Bernardo Ferreira.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>