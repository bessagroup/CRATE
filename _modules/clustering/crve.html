<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>clustering.crve &mdash; crate 1.0.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/readthedocs-custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            crate
          </a>
              <div class="version">
                1.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/getting_started/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/getting_started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/getting_started/run_benchmark.html">Run a benchmark</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Basic usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/basic_usage/general_workflow.html">General workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/basic_usage/step1_material_model.html">Step 1: Material model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/basic_usage/step2_input_data.html">Step 2: Input data file</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/basic_usage/step3_simulation.html">Step 3: Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/basic_usage/step4_post_processing.html">Step 4: Post-processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/basic_usage/available_features.html">Available features</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Validation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/validation/benchmarks.html">Benchmarks</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/advanced_usage/customization.html">Customization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/advanced_usage/interface_dns_solver.html">Interface: DNS solver</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/advanced_usage/interface_clustering_feature.html">Interface: Clustering feature</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/advanced_usage/interface_clustering_algorithm.html">Interface: Clustering algorithm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/advanced_usage/interface_constitutive_model.html">Interface: Constitutive model</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../rst_doc_files/reference/index.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../_autosummary/crate.html">Code</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">License</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">BSD 3-Clause License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">crate</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">clustering.crve</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for clustering.crve</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Cluster-Reduced Representative Volume Element.</span>

<span class="sd">This module includes the class that materializes a Cluster-Reduced</span>
<span class="sd">Representative Volume Element (CRVE) as an aggregation of Cluster-Reduced</span>
<span class="sd">Material Phases and a set of cluster interaction tensors. This class has the</span>
<span class="sd">high-level control of all clustering-related procedures, namely both base and</span>
<span class="sd">adaptive cluter analyses as well as the computation of the cluster interaction</span>
<span class="sd">tensors.</span>

<span class="sd">The concept of Cluster-Reduced Representative Volume Element arises in the</span>
<span class="sd">context of clustering-based reduced order modeling (see Chapter 4 of</span>
<span class="sd">Ferreira (2022) [#]_).</span>

<span class="sd">.. [#] Ferreira, B.P. (2022). *Towards Data-driven Multi-scale</span>
<span class="sd">       Optimization of Thermoplastic Blends: Microstructural</span>
<span class="sd">       Generation, Constitutive Development and Clustering-based</span>
<span class="sd">       Reduced-Order Modeling.* PhD Thesis, University of Porto</span>
<span class="sd">       (see `here &lt;https://repositorio-aberto.up.pt/handle/10216/</span>
<span class="sd">       146900?locale=en&gt;`_)</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>
<span class="sd">CRVE</span>
<span class="sd">    Cluster-Reduced Representative Volume Element.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#                                                                       Modules</span>
<span class="c1"># =============================================================================</span>
<span class="c1"># Standard</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="c1"># Third-party</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># Local</span>
<span class="kn">import</span> <span class="nn">ioput.info</span> <span class="k">as</span> <span class="nn">info</span>
<span class="kn">import</span> <span class="nn">tensor.matrixoperations</span> <span class="k">as</span> <span class="nn">mop</span>
<span class="kn">import</span> <span class="nn">clustering.citoperations</span> <span class="k">as</span> <span class="nn">citop</span>
<span class="kn">from</span> <span class="nn">clustering.clusteringphase</span> <span class="kn">import</span> <span class="n">SCRMP</span><span class="p">,</span> <span class="n">GACRMP</span><span class="p">,</span> <span class="n">HAACRMP</span>
<span class="c1">#</span>
<span class="c1">#                                                          Authorship &amp; Credits</span>
<span class="c1"># =============================================================================</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Bernardo Ferreira (bernardo_ferreira@brown.edu)&#39;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Bernardo Ferreira&#39;</span><span class="p">,</span> <span class="p">]</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s1">&#39;Stable&#39;</span>
<span class="c1"># =============================================================================</span>
<span class="c1">#</span>
<span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="CRVE"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE">[docs]</a><span class="k">class</span> <span class="nc">CRVE</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cluster-Reduced Representative Volume Element.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _n_dim : int</span>
<span class="sd">        Problem number of spatial dimensions.</span>
<span class="sd">    _comp_order_sym : list[str]</span>
<span class="sd">        Strain/Stress components symmetric order.</span>
<span class="sd">    _comp_order_nsym : list[str]</span>
<span class="sd">        Strain/Stress components nonsymmetric order.</span>
<span class="sd">    _n_voxels_dims : list[int]</span>
<span class="sd">        Number of voxels in each dimension of the regular grid (spatial</span>
<span class="sd">        discretization of the RVE).</span>
<span class="sd">    _n_voxels : int</span>
<span class="sd">        Total number of voxels of the regular grid (spatial discretization of</span>
<span class="sd">        the RVE).</span>
<span class="sd">    _phase_voxel_flatidx : dict</span>
<span class="sd">        Flat (1D) voxels&#39; indexes (item, list[int]) associated with each</span>
<span class="sd">        material phase (key, str).</span>
<span class="sd">    _gop_X_dft_vox : list[dict]</span>
<span class="sd">        Green operator material independent terms. Each term is stored in a</span>
<span class="sd">        dictionary, where each pair of strain/stress components (key, str) is</span>
<span class="sd">        associated with the Green operator material independent term evaluated</span>
<span class="sd">        in all spatial discrete points (item, numpy.ndarray (2d or 3d)).</span>
<span class="sd">    _cluster_phases : dict</span>
<span class="sd">        Cluster-Reduced material phase instance (item, CRMP) associated with</span>
<span class="sd">        each material phase (key, str).</span>
<span class="sd">    _base_phase_n_clusters : dict</span>
<span class="sd">        Number of clusters (item, int) prescribed (base clustering) for each</span>
<span class="sd">        material phase (key, str).</span>
<span class="sd">    _adaptive_step : int</span>
<span class="sd">        Counter of adaptive clustering steps, with 0 associated with the base</span>
<span class="sd">        clustering.</span>
<span class="sd">    _voxels_clusters : numpy.ndarray (2d or 3d)</span>
<span class="sd">        Regular grid of voxels (spatial discretization of the RVE), where each</span>
<span class="sd">        entry contains the cluster label (int) assigned to the corresponding</span>
<span class="sd">        voxel.</span>
<span class="sd">    _phase_clusters : dict</span>
<span class="sd">        Clusters labels (item, list[int]) associated with each material phase</span>
<span class="sd">        (key, str).</span>
<span class="sd">    _clusters_vf : dict</span>
<span class="sd">        Volume fraction (item, float) associated with each material cluster</span>
<span class="sd">        (key, str).</span>
<span class="sd">    _cit_x_mf : list[dict]</span>
<span class="sd">        Cluster interaction tensors associated with the Green operator material</span>
<span class="sd">        independent terms. Each term is stored in a dictionary (item, dict) for</span>
<span class="sd">        each pair of material phases (key, str), which in turn contains the</span>
<span class="sd">        corresponding matricial form (item, numpy.ndarray (2d)) associated with</span>
<span class="sd">        each pair of clusters (key, str).</span>
<span class="sd">    _adapt_material_phases : list[str]</span>
<span class="sd">        RVE adaptive material phases labels (str).</span>
<span class="sd">    _adaptive_clustering_time : float</span>
<span class="sd">        Total amount of time (s) spent in clustering adaptivity.</span>
<span class="sd">    _adaptive_cit_time : float</span>
<span class="sd">        Total amount of time (s) spent in clustering adaptivity cluster</span>
<span class="sd">        interaction tensors computation procedures.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    perform_crve_base_clustering(self)</span>
<span class="sd">        Compute CRVE base clustering.</span>
<span class="sd">    perform_crve_adaptivity(self, target_clusters, target_clusters_data)</span>
<span class="sd">        Perform CRVE clustering adaptivity.</span>
<span class="sd">    get_rve_dims(self)</span>
<span class="sd">        Get RVE dimensions.</span>
<span class="sd">    get_material_phases(self)</span>
<span class="sd">        Get RVE material phases.</span>
<span class="sd">    get_n_voxels(self)</span>
<span class="sd">        Get number of voxels in each dimension and total number of voxels.</span>
<span class="sd">    get_regular_grid(self)</span>
<span class="sd">        Get regular grid of voxels with material phase labels.</span>
<span class="sd">    get_phase_n_clusters(self)</span>
<span class="sd">        Get number of clusters associated with each material phase.</span>
<span class="sd">    get_phase_clusters(self)</span>
<span class="sd">        Get clusters associated with each material phase.</span>
<span class="sd">    get_voxels_clusters(self)</span>
<span class="sd">        Get regular grid containing the cluster label of each voxel.</span>
<span class="sd">    get_n_total_clusters(self)</span>
<span class="sd">        Get current total number of clusters.</span>
<span class="sd">    get_cluster_phases(self)</span>
<span class="sd">        Get cluster-reduced material phase instance of each material phase.</span>
<span class="sd">    get_clusters_vf(self)</span>
<span class="sd">        Get clusters volume fraction.</span>
<span class="sd">    get_cit_x_mf(self)</span>
<span class="sd">        Get cluster interaction tensors (Green material independent terms).</span>
<span class="sd">    get_eff_isotropic_elastic_constants(self)</span>
<span class="sd">        Get isotropic elastic constants from elastic tangent modulus.</span>
<span class="sd">    get_adapt_material_phases(self)</span>
<span class="sd">        Get adaptive material phases labels.</span>
<span class="sd">    get_adaptivity_control_feature(self)</span>
<span class="sd">        Get clustering adaptivity control feature of each material phase.</span>
<span class="sd">    get_adapt_criterion_data(self)</span>
<span class="sd">        Get clustering adaptivity criterion data of each material phase.</span>
<span class="sd">    get_voxels_array_variables(self)</span>
<span class="sd">        Get required variables to build a clusters state based voxels array.</span>
<span class="sd">    get_adaptive_step(self)</span>
<span class="sd">        Get counter of adaptive clustering steps.</span>
<span class="sd">    get_adaptive_clustering_time(self)</span>
<span class="sd">        Get total amount of time spent in clustering adaptivity.</span>
<span class="sd">    get_adaptive_cit_time(self)</span>
<span class="sd">        Get total time spent in adaptivity cluster interaction tensors.</span>
<span class="sd">    get_clustering_type(self)</span>
<span class="sd">        Get clustering type of each material phase.</span>
<span class="sd">    get_adaptivity_output(self)</span>
<span class="sd">        Get required data for clustering adaptivity output file.</span>
<span class="sd">    get_clustering_summary(self)</span>
<span class="sd">        Get summary of number of clusters of each material phase.</span>
<span class="sd">    reset_adaptive_parameters(self)</span>
<span class="sd">        Reset CRVE adaptive progress parameters and set base clustering.</span>
<span class="sd">    update_adaptive_parameters(self, adaptive_clustering_scheme, \</span>
<span class="sd">                               adapt_criterion_data, adaptivity_type, \</span>
<span class="sd">                               adaptivity_control_feature)</span>
<span class="sd">        Update CRVE clustering adaptivity attributes.</span>
<span class="sd">    get_crmp_types()</span>
<span class="sd">        Get available cluster-reduced material phases types.</span>
<span class="sd">    _get_features_indexes(clustering_scheme)</span>
<span class="sd">        Get unique clustering features indexes from clustering scheme.</span>
<span class="sd">    _get_phase_idxs(regular_grid, material_phases)</span>
<span class="sd">        Get flat indexes of each material phase&#39;s voxels.</span>
<span class="sd">    _get_cluster_idxs(voxels_clusters, cluster_label)</span>
<span class="sd">        Get flat indexes of given cluster&#39;s voxels.</span>
<span class="sd">    _set_phase_clusters(self)</span>
<span class="sd">        Set CRVE cluster labels associated with each material phase.</span>
<span class="sd">    _set_clusters_vf(self)</span>
<span class="sd">        Set CRVE clusters&#39; volume fractions.</span>
<span class="sd">    _get_clusters_max_label(self)</span>
<span class="sd">        Get CRVE maximum cluster label.</span>
<span class="sd">    _sort_cluster_labels(self)</span>
<span class="sd">        Reassign and sort CRVE cluster labels material phasewise.</span>
<span class="sd">    compute_cit(self, mode=&#39;full&#39;, adaptive_clustering_map=None)</span>
<span class="sd">        Compute CRVE cluster interaction tensors.</span>
<span class="sd">    _cluster_filter(self, cluster)</span>
<span class="sd">        Compute cluster discrete characteristic function.</span>
<span class="sd">    _gop_convolution(self, cluster_filter_dft, gop_1_dft_vox, \</span>
<span class="sd">                     gop_2_dft_vox, gop_0_freq_dft_vox)</span>
<span class="sd">        Convolution of cluster characteristic function and Green operator.</span>
<span class="sd">    _discrete_cit_integral(self, cluster_filter, gop_1_filt_vox, \</span>
<span class="sd">                           gop_2_filt_vox, gop_0_freq_filt_vox)</span>
<span class="sd">        Discrete integral over the spatial domain of material cluster.</span>
<span class="sd">    _switch_pair(x, delimiter=&#39;_&#39;)</span>
<span class="sd">        Switch left and right sides of string with separating delimiter.</span>
<span class="sd">    save_crve_file(crve, crve_file_path)</span>
<span class="sd">        Dump CRVE into file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.__init__"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rve_dims</span><span class="p">,</span> <span class="n">regular_grid</span><span class="p">,</span> <span class="n">material_phases</span><span class="p">,</span>
                 <span class="n">strain_formulation</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">,</span> <span class="n">global_data_matrix</span><span class="p">,</span>
                 <span class="n">clustering_type</span><span class="p">,</span> <span class="n">phase_n_clusters</span><span class="p">,</span> <span class="n">base_clustering_scheme</span><span class="p">,</span>
                 <span class="n">eff_elastic_properties</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">adaptive_clustering_scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">adapt_criterion_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">adaptivity_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">adaptivity_control_feature</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Constructor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rve_dims : list[float]</span>
<span class="sd">            RVE size in each dimension.</span>
<span class="sd">        regular_grid : numpy.ndarray (2d or 3d)</span>
<span class="sd">            Regular grid of voxels (spatial discretization of the RVE), where</span>
<span class="sd">            each entry contains the material phase label (int) assigned to the</span>
<span class="sd">            corresponding voxel.</span>
<span class="sd">        material_phases : list[str]</span>
<span class="sd">            RVE material phases labels (str).</span>
<span class="sd">        strain_formulation: {&#39;infinitesimal&#39;, &#39;finite&#39;}</span>
<span class="sd">            Problem strain formulation.</span>
<span class="sd">        problem_type : int</span>
<span class="sd">            Problem type: 2D plane strain (1), 2D plane stress (2),</span>
<span class="sd">            2D axisymmetric (3) and 3D (4).</span>
<span class="sd">        global_data_matrix: numpy.ndarray (2d)</span>
<span class="sd">            Data matrix (numpy.ndarray of shape (n_voxels, n_features_dims))</span>
<span class="sd">            containing the required clustering features&#39; data to perform all</span>
<span class="sd">            the prescribed cluster analyses.</span>
<span class="sd">        clustering_type : dict</span>
<span class="sd">            Clustering type (item, {&#39;static&#39;, &#39;adaptive&#39;}) of each material</span>
<span class="sd">            phase (key, str).</span>
<span class="sd">        phase_n_clusters : dict</span>
<span class="sd">            Number of clusters (item, int) associated with each material phase</span>
<span class="sd">            (key, str).</span>
<span class="sd">        base_clustering_scheme : dict</span>
<span class="sd">            Prescribed base clustering scheme (item, numpy.ndarray of shape</span>
<span class="sd">            (n_clusterings, 3)) for each material phase (key, str). Each row is</span>
<span class="sd">            associated with a unique clustering characterized by a clustering</span>
<span class="sd">            algorithm (col 1, int), a list of features (col 2, list[int]) and a</span>
<span class="sd">            list of the features data matrix&#39; indexes (col 3, list[int]).</span>
<span class="sd">        eff_elastic_properties : dict, default=None</span>
<span class="sd">            Elastic properties (key, str) and their values (item, float)</span>
<span class="sd">            estimated from the RVE&#39;s elastic effective tangent modulus.</span>
<span class="sd">        adaptive_clustering_scheme : dict</span>
<span class="sd">            Prescribed adaptive clustering scheme (item, numpy.ndarray of shape</span>
<span class="sd">            (n_clusterings, 3)) for each material phase (key, str). Each row is</span>
<span class="sd">            associated with a unique clustering characterized by a clustering</span>
<span class="sd">            algorithm (col 1, int), a list of features (col 2, list[int]) and a</span>
<span class="sd">            list of the features data matrix&#39; indexes (col 3, list[int]).</span>
<span class="sd">        adapt_criterion_data : dict, default=None</span>
<span class="sd">            Clustering adaptivity criterion (item, dict) associated with each</span>
<span class="sd">            material phase (key, str). This dictionary contains the adaptivity</span>
<span class="sd">            criterion to be used and the required parameters.</span>
<span class="sd">        adaptivity_type : dict, default=None</span>
<span class="sd">            Clustering adaptivity type (item, dict) associated with each</span>
<span class="sd">            material phase (key, str). This dictionary contains the adaptivity</span>
<span class="sd">            type to be used and the required parameters.</span>
<span class="sd">        adaptivity_control_feature : dict, default=None</span>
<span class="sd">            Clustering adaptivity control feature (item, str) associated with</span>
<span class="sd">            each material phase (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rve_dims</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">rve_dims</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_regular_grid</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">regular_grid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">material_phases</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">=</span> <span class="n">strain_formulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span> <span class="o">=</span> <span class="n">problem_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_global_data_matrix</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">global_data_matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clustering_type</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">clustering_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phase_n_clusters</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">phase_n_clusters</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_clustering_scheme</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">base_clustering_scheme</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_eff_elastic_properties</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">eff_elastic_properties</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_clustering_scheme</span> <span class="o">=</span> \
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">adaptive_clustering_scheme</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptivity_type</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">adaptivity_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gop_X_dft_vox</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_phases</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_step</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phase_clusters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clusters_vf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptivity_control_feature</span> <span class="o">=</span> \
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">adaptivity_control_feature</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_criterion_data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">adapt_criterion_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_clustering_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_cit_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Get problem type parameters</span>
        <span class="n">n_dim</span><span class="p">,</span> <span class="n">comp_order_sym</span><span class="p">,</span> <span class="n">comp_order_nsym</span> <span class="o">=</span> \
            <span class="n">mop</span><span class="o">.</span><span class="n">get_problem_type_parameters</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_dim</span> <span class="o">=</span> <span class="n">n_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span> <span class="o">=</span> <span class="n">comp_order_sym</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span> <span class="o">=</span> <span class="n">comp_order_nsym</span>
        <span class="c1"># Get number of voxels on each dimension and total number of voxels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_voxels_dims</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">regular_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">regular_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">))]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_voxels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_voxels_dims</span><span class="p">)</span>
        <span class="c1"># Get material phases&#39; voxels&#39; 1D flat indexes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phase_voxel_flatidx</span> <span class="o">=</span> \
            <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_get_phase_idxs</span><span class="p">(</span><span class="n">regular_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">)</span>
        <span class="c1"># Get adaptive material phases</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_material_phases</span> <span class="o">=</span> \
            <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clustering_type</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
             <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clustering_type</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;adaptive&#39;</span><span class="p">]</span>
        <span class="c1"># Set number of clusters prescribed (base clustering) for each material</span>
        <span class="c1"># phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_phase_n_clusters</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_n_clusters</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.perform_crve_base_clustering"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.perform_crve_base_clustering">[docs]</a>    <span class="k">def</span> <span class="nf">perform_crve_base_clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute CRVE base clustering.&quot;&quot;&quot;</span>
        <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;5&#39;</span><span class="p">,</span> <span class="s1">&#39;Computing CRVE base clustering...&#39;</span><span class="p">)</span>
        <span class="c1"># Initialize base clustering labels</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_voxels</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="c1"># Initialize cluster-reduced material phases dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_phases</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Initialize minimum cluster label</span>
        <span class="n">min_label</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
            <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;5&#39;</span><span class="p">,</span> <span class="s1">&#39;Computing material phase &#39;</span> <span class="o">+</span> <span class="n">mat_phase</span>
                             <span class="o">+</span> <span class="s1">&#39; base clustering...&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="c1"># Get material phase clustering type</span>
            <span class="n">ctype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clustering_type</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span>
            <span class="c1"># Get material phase initial number of clusters</span>
            <span class="n">n_phase_clusters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_phase_n_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Get material phase&#39;s voxels&#39; indexes</span>
            <span class="n">voxels_idxs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phase_voxel_flatidx</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Get material phase cluster data matrix containing the required</span>
            <span class="c1"># data to perform all the prescribed cluster analyses (condensation</span>
            <span class="c1"># in terms of voxels only)</span>
            <span class="n">cluster_data_matrix</span> <span class="o">=</span> <span class="n">mop</span><span class="o">.</span><span class="n">get_condensed_matrix</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_global_data_matrix</span><span class="p">,</span> <span class="n">voxels_idxs</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_global_data_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Instatiate cluster-reduced material phase</span>
            <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s1">&#39;static&#39;</span><span class="p">:</span>
                <span class="c1"># Instantiate static cluster-reduced material phase</span>
                <span class="n">crmp</span> <span class="o">=</span> <span class="n">SCRMP</span><span class="p">(</span><span class="n">mat_phase</span><span class="p">,</span> <span class="n">cluster_data_matrix</span><span class="p">,</span> <span class="n">n_phase_clusters</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ctype</span> <span class="o">==</span> <span class="s1">&#39;adaptive&#39;</span><span class="p">:</span>
                <span class="c1"># Get material phase adaptivity type</span>
                <span class="n">atype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adaptivity_type</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">][</span><span class="s1">&#39;adapt_type&#39;</span><span class="p">]</span>
                <span class="c1"># Instantiate adaptive cluster-reduced material phase</span>
                <span class="k">if</span> <span class="n">atype</span> <span class="o">==</span> <span class="n">GACRMP</span><span class="p">:</span>
                    <span class="c1"># Instantiate generalized adaptive cluster-reduced material</span>
                    <span class="c1"># phase</span>
                    <span class="n">crmp</span> <span class="o">=</span> <span class="n">GACRMP</span><span class="p">(</span><span class="n">mat_phase</span><span class="p">,</span> <span class="n">cluster_data_matrix</span><span class="p">,</span>
                                  <span class="n">n_phase_clusters</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">_adaptivity_type</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">atype</span> <span class="o">==</span> <span class="n">HAACRMP</span><span class="p">:</span>
                    <span class="c1"># Instantiate hierarchical-agglomerative adaptive</span>
                    <span class="c1"># cluster-reduced material phase</span>
                    <span class="n">crmp</span> <span class="o">=</span> <span class="n">HAACRMP</span><span class="p">(</span><span class="n">mat_phase</span><span class="p">,</span> <span class="n">cluster_data_matrix</span><span class="p">,</span>
                                   <span class="n">n_phase_clusters</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">_adaptivity_type</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown adaptivity type.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown material phase clustering type.&#39;</span><span class="p">)</span>
            <span class="c1"># Store cluster-reduced material phase</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_phases</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span> <span class="o">=</span> <span class="n">crmp</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Get material phase base clustering scheme</span>
            <span class="n">clustering_scheme</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_base_clustering_scheme</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span>
            <span class="c1"># Perform material phase base clustering</span>
            <span class="n">crmp</span><span class="o">.</span><span class="n">perform_base_clustering</span><span class="p">(</span><span class="n">clustering_scheme</span><span class="p">,</span> <span class="n">min_label</span><span class="p">)</span>
            <span class="c1"># Update minimum cluster label</span>
            <span class="n">min_label</span> <span class="o">=</span> <span class="n">crmp</span><span class="o">.</span><span class="n">max_label</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Check for duplicated cluster labels</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">crmp</span><span class="o">.</span><span class="n">cluster_labels</span><span class="p">)</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Duplicated cluster labels between &#39;</span>
                                   <span class="s1">&#39;different material phases.&#39;</span><span class="p">)</span>
            <span class="c1"># Assemble material phase cluster labels</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">voxels_idxs</span><span class="p">]</span> <span class="o">=</span> <span class="n">crmp</span><span class="o">.</span><span class="n">cluster_labels</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build base CRVE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_n_voxels_dims</span><span class="p">)</span>
        <span class="c1"># Compute base CRVE descriptors</span>
        <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;5&#39;</span><span class="p">,</span> <span class="s1">&#39;Computing CRVE base clustering descriptors...&#39;</span><span class="p">,</span>
                         <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Store cluster labels belonging to each material phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_phase_clusters</span><span class="p">()</span>
        <span class="c1"># Compute material clusters&#39; volume fraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_clusters_vf</span><span class="p">()</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.perform_crve_adaptivity"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.perform_crve_adaptivity">[docs]</a>    <span class="k">def</span> <span class="nf">perform_crve_adaptivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_clusters</span><span class="p">,</span> <span class="n">target_clusters_data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform CRVE clustering adaptivity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        target_clusters : list[int]</span>
<span class="sd">            List with the labels (int) of clusters to be adapted.</span>
<span class="sd">        target_clusters_data : dict</span>
<span class="sd">            For each target cluster (key, str), store dictionary (item, dict)</span>
<span class="sd">            containing cluster associated parameters relevant for the adaptive</span>
<span class="sd">            procedures.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adaptive_clustering_map : dict</span>
<span class="sd">            Adaptive clustering map (item, dict with list of new cluster labels</span>
<span class="sd">            (item, list[int]) resulting from the refinement of each target</span>
<span class="sd">            cluster (key, str)) for each material phase (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check for duplicated target clusters</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_clusters</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">target_clusters</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;List of target clusters contains duplicated &#39;</span>
                               <span class="s1">&#39;labels.&#39;</span><span class="p">)</span>
        <span class="c1"># Check for unexistent target clusters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">target_clusters</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span><span class="o">.</span><span class="n">flatten</span><span class="p">())):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;List of target clusters contains unexistent &#39;</span>
                               <span class="s1">&#39;labels.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="n">init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Increment adaptive clustering refinement step counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_step</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Get CRVE current clustering</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="c1"># Initialize adaptive material phase&#39;s target clusters and associated</span>
        <span class="c1"># data</span>
        <span class="n">phase_target_clusters</span> <span class="o">=</span> <span class="p">{</span><span class="n">mat_phase</span><span class="p">:</span> <span class="p">[]</span>
                                 <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_material_phases</span><span class="p">}</span>
        <span class="n">phase_target_clusters_data</span> <span class="o">=</span> \
            <span class="p">{</span><span class="n">mat_phase</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_material_phases</span><span class="p">}</span>
        <span class="c1"># Build adaptive material phase&#39;s target clusters lists and associated</span>
        <span class="c1"># data</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_material_phases</span><span class="p">:</span>
            <span class="n">phase_target_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span> <span class="o">=</span> \
                <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">target_clusters</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_phase_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]))</span>
            <span class="n">phase_target_clusters_data</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">):</span> <span class="n">target_clusters_data</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span>
                 <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">phase_target_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]}</span>
        <span class="c1"># Get CRVE maximum cluster label</span>
        <span class="n">max_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_clusters_max_label</span><span class="p">()</span>
        <span class="c1"># Set minimum cluster label</span>
        <span class="n">min_label</span> <span class="o">=</span> <span class="n">max_label</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize adaptive clustering map</span>
        <span class="n">adaptive_clustering_map</span> <span class="o">=</span> \
            <span class="p">{</span><span class="n">mat_phase</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_material_phases</span><span class="p">}</span>
        <span class="c1"># Loop over adaptive material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_material_phases</span><span class="p">:</span>
            <span class="c1"># If there are no target clusters, skip to next adaptive material</span>
            <span class="c1"># phase</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">phase_target_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="c1"># Get cluster-reduced material phase</span>
            <span class="n">crmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_phases</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span>
            <span class="c1"># Get adaptive clustering scheme</span>
            <span class="n">adaptive_clustering_scheme</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_clustering_scheme</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span>
            <span class="c1"># Perform adaptive clustering</span>
            <span class="n">adaptive_clustering_map</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">crmp</span><span class="o">.</span><span class="n">perform_adaptive_clustering</span><span class="p">(</span>
                    <span class="n">phase_target_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">],</span>
                    <span class="n">phase_target_clusters_data</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">],</span>
                    <span class="n">adaptive_clustering_scheme</span><span class="p">,</span> <span class="n">min_label</span><span class="p">)</span>
            <span class="c1"># Update minimum cluster label</span>
            <span class="n">min_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_clusters_max_label</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Update CRVE clustering</span>
            <span class="n">labels</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_voxel_flatidx</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]]</span> <span class="o">=</span> <span class="n">crmp</span><span class="o">.</span><span class="n">cluster_labels</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build adaptive CRVE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">_n_voxels_dims</span><span class="p">)</span>
        <span class="c1"># Store cluster labels and update number of clusters belonging to each</span>
        <span class="c1"># material phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_phase_clusters</span><span class="p">()</span>
        <span class="c1"># Compute material clusters&#39; volume fraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_clusters_vf</span><span class="p">()</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Update total amount of time spent in clustering adaptivity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_clustering_time</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">init_time</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">adaptive_clustering_map</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_rve_dims"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_rve_dims">[docs]</a>    <span class="k">def</span> <span class="nf">get_rve_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get RVE dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        rve_dims : list</span>
<span class="sd">            RVE size in each dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rve_dims</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_material_phases"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_material_phases">[docs]</a>    <span class="k">def</span> <span class="nf">get_material_phases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get RVE material phases.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        material_phases : list</span>
<span class="sd">            RVE material phases labels (str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_n_voxels"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_n_voxels">[docs]</a>    <span class="k">def</span> <span class="nf">get_n_voxels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get number of voxels in each dimension and total number of voxels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_voxels_dims : list[int]</span>
<span class="sd">            Number of voxels in each dimension of the regular grid (spatial</span>
<span class="sd">            discretization of the RVE).</span>
<span class="sd">        n_voxels : int</span>
<span class="sd">            Total number of voxels of the regular grid (spatial discretization</span>
<span class="sd">            of the RVE).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_voxels_dims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_voxels</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_regular_grid"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_regular_grid">[docs]</a>    <span class="k">def</span> <span class="nf">get_regular_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get regular grid of voxels with material phase labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        regular_grid : numpy.ndarray (2d or 3d)</span>
<span class="sd">            Regular grid of voxels (spatial discretization of the RVE), where</span>
<span class="sd">            each entry contains the material phase label (int) assigned to the</span>
<span class="sd">            corresponding voxel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_regular_grid</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_phase_n_clusters"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_phase_n_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">get_phase_n_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get number of clusters associated with each material phase.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        phase_n_clusters : dict</span>
<span class="sd">            Number of clusters (item, int) associated with each material phase</span>
<span class="sd">            (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_n_clusters</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_phase_clusters"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_phase_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">get_phase_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get clusters associated with each material phase.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        phase_clusters : dict</span>
<span class="sd">            Clusters labels (item, list[int]) associated with each material</span>
<span class="sd">            phase (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_clusters</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_voxels_clusters"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_voxels_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">get_voxels_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get regular grid containing the cluster label of each voxel.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        voxels_clusters : numpy.ndarray (2d or 3d)</span>
<span class="sd">            Regular grid of voxels (spatial discretization of the RVE), where</span>
<span class="sd">            each entry contains the cluster label (int) assigned to the</span>
<span class="sd">            corresponding voxel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_n_total_clusters"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_n_total_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">get_n_total_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get current total number of clusters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_total_clusters : int</span>
<span class="sd">            Total number of clusters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize total number of clusters</span>
        <span class="n">n_total_clusters</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Loop over material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
            <span class="n">n_total_clusters</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">])</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">n_total_clusters</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_cluster_phases"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_cluster_phases">[docs]</a>    <span class="k">def</span> <span class="nf">get_cluster_phases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get cluster-reduced material phase instance of each material phase.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cluster_phases : dict</span>
<span class="sd">            Cluster-Reduced material phase instance (item, CRMP) associated</span>
<span class="sd">            with each material phase (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cluster_phases</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_clusters_vf"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_clusters_vf">[docs]</a>    <span class="k">def</span> <span class="nf">get_clusters_vf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get clusters volume fraction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clusters_vf : dict</span>
<span class="sd">            Volume fraction (item, float) associated with each material cluster</span>
<span class="sd">            (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clusters_vf</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_cit_x_mf"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_cit_x_mf">[docs]</a>    <span class="k">def</span> <span class="nf">get_cit_x_mf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get cluster interaction tensors (Green material independent terms).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cit_x_mf : list[dict]</span>
<span class="sd">            Cluster interaction tensors associated with the Green operator</span>
<span class="sd">            material independent terms. Each term is stored in a dictionary</span>
<span class="sd">            (item, dict) for each pair of material phases (key, str), which in</span>
<span class="sd">            turn contains the corresponding matricial form (item,</span>
<span class="sd">            numpy.ndarray (2d)) associated with each pair of clusters</span>
<span class="sd">            (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_eff_isotropic_elastic_constants"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_eff_isotropic_elastic_constants">[docs]</a>    <span class="k">def</span> <span class="nf">get_eff_isotropic_elastic_constants</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get isotropic elastic constants from elastic tangent modulus.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eff_elastic_properties : dict</span>
<span class="sd">            Elastic properties (key, str) and their values (item, float)</span>
<span class="sd">            estimated from the RVE&#39;s elastic effective tangent modulus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_eff_elastic_properties</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_adapt_material_phases"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_adapt_material_phases">[docs]</a>    <span class="k">def</span> <span class="nf">get_adapt_material_phases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get adaptive material phases labels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adapt_material_phases : list[str]</span>
<span class="sd">            RVE adaptive material phases labels (str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adapt_material_phases</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_adaptivity_control_feature"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_adaptivity_control_feature">[docs]</a>    <span class="k">def</span> <span class="nf">get_adaptivity_control_feature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get clustering adaptivity control feature of each material phase.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adaptivity_control_feature : dict, default=None</span>
<span class="sd">            Clustering adaptivity control feature (item, str) associated with</span>
<span class="sd">            each material phase (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adaptivity_control_feature</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_adapt_criterion_data"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_adapt_criterion_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_adapt_criterion_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get clustering adaptivity criterion data of each material phase.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adapt_criterion_data : dict, default=None</span>
<span class="sd">            Clustering adaptivity criterion (item, dict) associated with each</span>
<span class="sd">            material phase (key, str). This dictionary contains the adaptivity</span>
<span class="sd">            criterion to be used and the required parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_adapt_criterion_data</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_voxels_array_variables"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_voxels_array_variables">[docs]</a>    <span class="k">def</span> <span class="nf">get_voxels_array_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get required variables to build a clusters state based voxels array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        material_phases : list</span>
<span class="sd">            CRVE material phases labels (str).</span>
<span class="sd">        phase_clusters : dict</span>
<span class="sd">            Clusters labels (item, list of int) associated with each material</span>
<span class="sd">            phase (key, str).</span>
<span class="sd">        voxels_clusters : ndarray</span>
<span class="sd">            Regular grid of voxels (spatial discretization of the RVE), where</span>
<span class="sd">            each entry contains the cluster label (int) assigned to the</span>
<span class="sd">            corresponding voxel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phase_clusters</span><span class="p">,</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_adaptive_step"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_adaptive_step">[docs]</a>    <span class="k">def</span> <span class="nf">get_adaptive_step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get counter of adaptive clustering steps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adaptive_step : int</span>
<span class="sd">            Counter of adaptive clustering steps, with 0 associated with the</span>
<span class="sd">            base clustering.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_step</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_adaptive_clustering_time"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_adaptive_clustering_time">[docs]</a>    <span class="k">def</span> <span class="nf">get_adaptive_clustering_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get total amount of time spent in clustering adaptivity.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adaptive_clustering_time : float</span>
<span class="sd">            Total amount of time (s) spent in clustering adaptivity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_clustering_time</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_adaptive_cit_time"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_adaptive_cit_time">[docs]</a>    <span class="k">def</span> <span class="nf">get_adaptive_cit_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get total time spent in adaptivity cluster interaction tensors.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adaptive_cit_time : float</span>
<span class="sd">            Total amount of time (s) spent in clustering adaptivity cluster</span>
<span class="sd">            interaction tensors computation procedures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_cit_time</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_clustering_type"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_clustering_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_clustering_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get clustering type of each material phase.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clustering_type : dict</span>
<span class="sd">            Clustering type (item, {&#39;static&#39;, &#39;adaptive&#39;}) of each material</span>
<span class="sd">            phase (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clustering_type</span><span class="p">)</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_adaptivity_output"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_adaptivity_output">[docs]</a>    <span class="k">def</span> <span class="nf">get_adaptivity_output</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get required data for clustering adaptivity output file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        adaptivity_output : dict</span>
<span class="sd">            For each adaptive material phase (key, str), stores a list (item)</span>
<span class="sd">            containing the adaptivity metrics associated with the clustering</span>
<span class="sd">            adaptivity output file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize adaptivity output</span>
        <span class="n">adaptivity_output</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Loop over adaptive material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_material_phases</span><span class="p">:</span>
            <span class="c1"># Get adaptive cluster reduced material phase</span>
            <span class="n">acrmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_phases</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span>
            <span class="c1"># Get material phase adaptivity metrics</span>
            <span class="n">adaptivity_output</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">[</span><span class="o">*</span><span class="n">acrmp</span><span class="o">.</span><span class="n">get_adaptive_output</span><span class="p">()]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">adaptivity_output</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_clustering_summary"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_clustering_summary">[docs]</a>    <span class="k">def</span> <span class="nf">get_clustering_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get summary of number of clusters of each material phase.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        clustering_summary : dict</span>
<span class="sd">            For each material phase (key, str), stores list (item) containing</span>
<span class="sd">            the associated type (&#39;static&#39; or &#39;adaptive&#39;), the base number of</span>
<span class="sd">            clusters (int) and the final number of clusters (int).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize clustering summary</span>
        <span class="n">clustering_summary</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Loop over material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
            <span class="c1"># Build material phase clustering summary</span>
            <span class="n">clustering_summary</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_clustering_type</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">],</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_base_phase_n_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">],</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_phases</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span><span class="o">.</span><span class="n">get_n_clusters</span><span class="p">()]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">clustering_summary</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.reset_adaptive_parameters"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.reset_adaptive_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">reset_adaptive_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset CRVE adaptive progress parameters and set base clustering.&quot;&quot;&quot;</span>
        <span class="c1"># Reset counter of adaptive clustering steps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_step</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Set number of clusters prescribed (base clustering) for each material</span>
        <span class="c1"># phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_phase_n_clusters</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_n_clusters</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Reset time spent in clustering adaptivity procedures</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_clustering_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_cit_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over adaptive material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_material_phases</span><span class="p">:</span>
            <span class="c1"># Get cluster-reduced material phase</span>
            <span class="n">crmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_phases</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span>
            <span class="c1"># Reset adaptive progress parameters</span>
            <span class="n">crmp</span><span class="o">.</span><span class="n">reset_adaptive_parameters</span><span class="p">()</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.update_adaptive_parameters"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.update_adaptive_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">update_adaptive_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">adaptive_clustering_scheme</span><span class="p">,</span>
                                   <span class="n">adapt_criterion_data</span><span class="p">,</span> <span class="n">adaptivity_type</span><span class="p">,</span>
                                   <span class="n">adaptivity_control_feature</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update CRVE clustering adaptivity attributes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        adaptive_clustering_scheme : dict</span>
<span class="sd">            Prescribed adaptive clustering scheme (item, numpy.ndarray of shape</span>
<span class="sd">            (n_clusterings, 3)) for each material phase (key, str). Each row is</span>
<span class="sd">            associated with a unique clustering characterized by a clustering</span>
<span class="sd">            algorithm (col 1, int), a list of features (col 2, list[int]) and a</span>
<span class="sd">            list of the features data matrix&#39; indexes (col 3, list[int]).</span>
<span class="sd">        adapt_criterion_data : dict</span>
<span class="sd">            Clustering adaptivity criterion (item, dict) associated with each</span>
<span class="sd">            material phase (key, str). This dictionary contains the adaptivity</span>
<span class="sd">            criterion to be used and the required parameters.</span>
<span class="sd">        adaptivity_type : dict</span>
<span class="sd">            Clustering adaptivity type (item, dict) associated with each</span>
<span class="sd">            material phase (key, str). This dictionary contains the adaptivity</span>
<span class="sd">            type to be used and the required parameters.</span>
<span class="sd">        adaptivity_control_feature : dict</span>
<span class="sd">            Clustering adaptivity control feature (item, str) associated with</span>
<span class="sd">            each material phase (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update prescribed adaptive clustering scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_clustering_scheme</span> <span class="o">=</span> \
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">adaptive_clustering_scheme</span><span class="p">)</span>
        <span class="c1"># Update clustering adaptivity criterion data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_criterion_data</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">adapt_criterion_data</span><span class="p">)</span>
        <span class="c1"># Update clustering adaptivity type data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptivity_type</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">adaptivity_type</span><span class="p">)</span>
        <span class="c1"># Update clustering adaptivity control feature data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_adaptivity_control_feature</span> <span class="o">=</span> \
            <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">adaptivity_control_feature</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over adaptive material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_adapt_material_phases</span><span class="p">:</span>
            <span class="c1"># Get adaptive clustering scheme features indexes from the base</span>
            <span class="c1"># clustering scheme</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_clustering_scheme</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_clustering_scheme</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_base_clustering_scheme</span><span class="p">[</span>
                        <span class="n">mat_phase</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Get cluster-reduced material phase</span>
            <span class="n">crmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_phases</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span>
            <span class="c1"># Update clustering adaptivity type parameters</span>
            <span class="n">crmp</span><span class="o">.</span><span class="n">update_adaptivity_type</span><span class="p">(</span><span class="n">adaptivity_type</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">])</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.get_crmp_types"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.get_crmp_types">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_crmp_types</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get available cluster-reduced material phases types.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        available_crmp_types : dict</span>
<span class="sd">            Available cluster-reduced material phase classes (item, CRMP) and</span>
<span class="sd">            associated identifiers (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set available cluster-reduced material phase types</span>
        <span class="n">available_crmp_types</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="n">SCRMP</span><span class="p">,</span>
                                <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="n">GACRMP</span><span class="p">,</span>
                                <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="n">HAACRMP</span><span class="p">}</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Return</span>
        <span class="k">return</span> <span class="n">available_crmp_types</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE._get_features_indexes"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE._get_features_indexes">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_features_indexes</span><span class="p">(</span><span class="n">clustering_scheme</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get unique clustering features indexes from clustering scheme.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        clustering_scheme : ndarry of shape (n_clusterings, 3)</span>
<span class="sd">            Clustering scheme (numpy.ndarray of shape (n_clusterings, 3)). Each</span>
<span class="sd">            row is associated with a unique clustering characterized by a</span>
<span class="sd">            clustering algorithm (col 1, int), a list of features</span>
<span class="sd">            (col 2, list[int]) and a list of the features data matrix&#39; indexes</span>
<span class="sd">            (col 3, list[int]).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        indexes : list[int]</span>
<span class="sd">            List of unique clustering features indexes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Collect prescribed clusterings features&#39; indexes</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">clustering_scheme</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">indexes</span> <span class="o">+=</span> <span class="n">clustering_scheme</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="c1"># Get list of unique clustering features&#39; indexes</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">indexes</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">indexes</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE._get_phase_idxs"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE._get_phase_idxs">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_phase_idxs</span><span class="p">(</span><span class="n">regular_grid</span><span class="p">,</span> <span class="n">material_phases</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get flat indexes of each material phase&#39;s voxels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        regular_grid : numpy.ndarray (2d or 3d)</span>
<span class="sd">            Regular grid of voxels (spatial discretization of the RVE), where</span>
<span class="sd">            each entry contains the material phase label (int) assigned to the</span>
<span class="sd">            corresponding voxel.</span>
<span class="sd">        material_phases : list[str]</span>
<span class="sd">            RVE material phases labels (str).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        phase_voxel_flat_idx : dict</span>
<span class="sd">            Flat voxels&#39; indexes (item, list[int]) associated with each</span>
<span class="sd">            material phase (key, str).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phase_voxel_flat_idx</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># Loop over material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="n">material_phases</span><span class="p">:</span>
            <span class="c1"># Build boolean &#39;belongs to material phase&#39; list</span>
            <span class="n">is_phase_list</span> <span class="o">=</span> <span class="n">regular_grid</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">mat_phase</span><span class="p">)</span>
            <span class="c1"># Get material phase&#39;s voxels&#39; indexes</span>
            <span class="n">phase_voxel_flat_idx</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">it</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">is_phase_list</span><span class="p">)),</span> <span class="n">is_phase_list</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">phase_voxel_flat_idx</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE._get_cluster_idxs"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE._get_cluster_idxs">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_cluster_idxs</span><span class="p">(</span><span class="n">voxels_clusters</span><span class="p">,</span> <span class="n">cluster_label</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get flat indexes of given cluster&#39;s voxels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        voxels_clusters : numpy.ndarray (2d or 3d)</span>
<span class="sd">            Regular grid of voxels (spatial discretization of the RVE), where</span>
<span class="sd">            each entry contains the cluster label (int) assigned to the</span>
<span class="sd">            corresponding voxel.</span>
<span class="sd">        cluster_label : int</span>
<span class="sd">            Cluster label.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cluster_voxel_flat_idx : list[int]</span>
<span class="sd">            Flat voxels&#39; indexes (int) associated with given material cluster.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Build boolean &#39;belongs to cluster&#39; list</span>
        <span class="n">is_cluster_list</span> <span class="o">=</span> <span class="n">voxels_clusters</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">cluster_label</span><span class="p">)</span>
        <span class="c1"># Get material phase&#39;s voxels&#39; indexes</span>
        <span class="n">cluster_voxel_flat_idx</span> <span class="o">=</span> \
            <span class="nb">list</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">is_cluster_list</span><span class="p">)),</span> <span class="n">is_cluster_list</span><span class="p">))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">cluster_voxel_flat_idx</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE._set_phase_clusters"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE._set_phase_clusters">[docs]</a>    <span class="k">def</span> <span class="nf">_set_phase_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set CRVE cluster labels associated with each material phase.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_phase_clusters</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Loop over material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
            <span class="c1"># Get cluster labels</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_phase_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span> <span class="o">=</span> \
                <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">_phase_voxel_flatidx</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]]))</span>
            <span class="c1"># Update material phase number of clusters</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_phase_n_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span> <span class="o">=</span> \
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">])</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE._set_clusters_vf"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE._set_clusters_vf">[docs]</a>    <span class="k">def</span> <span class="nf">_set_clusters_vf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set CRVE clusters&#39; volume fractions.&quot;&quot;&quot;</span>
        <span class="c1"># Compute voxel volume</span>
        <span class="n">voxel_vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rve_dims</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_voxels_dims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rve_dims</span><span class="p">))])</span>
        <span class="c1"># Compute RVE volume</span>
        <span class="n">rve_vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rve_dims</span><span class="p">)</span>
        <span class="c1"># Compute volume fraction associated with each material cluster</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clusters_vf</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cluster</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span><span class="p">):</span>
            <span class="n">n_voxels_cluster</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span> <span class="o">==</span> <span class="n">cluster</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clusters_vf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster</span><span class="p">)]</span> <span class="o">=</span> \
                <span class="p">(</span><span class="n">n_voxels_cluster</span><span class="o">*</span><span class="n">voxel_vol</span><span class="p">)</span><span class="o">/</span><span class="n">rve_vol</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE._get_clusters_max_label"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE._get_clusters_max_label">[docs]</a>    <span class="k">def</span> <span class="nf">_get_clusters_max_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get CRVE maximum cluster label.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        max_label : int</span>
<span class="sd">            CRVE maximum cluster label.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize maximum cluster label</span>
        <span class="n">max_label</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># Loop over material phases</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
            <span class="c1"># Get cluster-reduced material phase</span>
            <span class="n">crmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_phases</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span>
            <span class="c1"># Update maximum cluster label</span>
            <span class="n">max_label</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_label</span><span class="p">,</span> <span class="n">crmp</span><span class="o">.</span><span class="n">max_label</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">max_label</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE._sort_cluster_labels"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE._sort_cluster_labels">[docs]</a>    <span class="k">def</span> <span class="nf">_sort_cluster_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reassign and sort CRVE cluster labels material phasewise.</span>

<span class="sd">        Reassign CRVE cluster labels in the range (0, n_clusters) and sort them</span>
<span class="sd">        in ascending order of material phase&#39;s labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize material phase initial cluster label</span>
        <span class="n">lbl_init</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Initialize old cluster labels</span>
        <span class="n">old_clusters</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize mapping dictionary to sort the cluster labels in asceding</span>
        <span class="c1"># order of material phase</span>
        <span class="n">sort_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># Loop over material phases sorted in ascending order</span>
        <span class="n">sorted_mat_phases</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="n">sorted_mat_phases</span><span class="p">:</span>
            <span class="c1"># Get material phase old cluster labels</span>
            <span class="n">phase_old_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_phase_voxel_flatidx</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]])</span>
            <span class="c1"># Set material phase new cluster labels</span>
            <span class="n">phase_new_clusters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="n">lbl_init</span><span class="p">,</span> <span class="n">lbl_init</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phase_n_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]))</span>
            <span class="c1"># Build mapping dictionary to sort the cluster labels</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_n_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">phase_old_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">sort_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cluster label (key) already exists in &#39;</span>
                                       <span class="s1">&#39;cluster labels mapping dictionary.&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sort_dict</span><span class="p">[</span><span class="n">phase_old_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">phase_new_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># Set next material phase initial cluster label</span>
            <span class="n">lbl_init</span> <span class="o">=</span> <span class="n">lbl_init</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phase_n_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span>
            <span class="c1"># Append old cluster labels</span>
            <span class="n">old_clusters</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">phase_old_clusters</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Check cluster labels mapping dictionary</span>
        <span class="n">new_clusters</span> <span class="o">=</span> <span class="p">[</span><span class="n">sort_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">sort_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">sort_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">old_clusters</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_clusters</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">old_clusters</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Invalid cluster labels mapping dictionary.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Sort cluster labels in ascending order of material phase</span>
        <span class="k">for</span> <span class="n">voxel_idx</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_voxels_dims</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_voxels_dims</span><span class="p">))]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span><span class="p">[</span><span class="n">voxel_idx</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">sort_dict</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span><span class="p">[</span><span class="n">voxel_idx</span><span class="p">]]</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.compute_cit"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.compute_cit">[docs]</a>    <span class="k">def</span> <span class="nf">compute_cit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">adaptive_clustering_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute CRVE cluster interaction tensors.</span>

<span class="sd">        *Cluster interaction tensors:*</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\boldsymbol{\\mathsf{T}}^{(I)(J)} = \\dfrac{1}{f^{(I)} v_{\\mu}}</span>
<span class="sd">           \\int_{\\Omega_{\\mu, \\, 0}} \\int_{\\Omega_{\\mu, \\, 0}}</span>
<span class="sd">           \\chi^{(I)}(\\boldsymbol{Y}) \\, \\chi^{(J)} (\\boldsymbol{Y}&#39;) \\,</span>
<span class="sd">           \\boldsymbol{\\mathsf{\\Phi}}^{0} (\\boldsymbol{Y}-\\boldsymbol{Y}&#39;)</span>
<span class="sd">           \\, \\mathrm{d} v&#39; \\mathrm{d} v \\, ,</span>

<span class="sd">        .. math::</span>
<span class="sd">           \\quad I,J = 1,2,\\dots, n_{\\mathrm{c}}</span>

<span class="sd">        where :math:`\\boldsymbol{\\mathsf{T}}^{(I)(J)}` is the cluster</span>
<span class="sd">        interaction tensor (fourth-order tensor) between the :math:`I` th</span>
<span class="sd">        and :math:`J` th material clusters, :math:`f^{(I)}` is the volume</span>
<span class="sd">        fraction of the :math:`I` th material cluster, :math:`v_{\\mu}` is</span>
<span class="sd">        the volume of the CRVE, :math:`\\boldsymbol{Y}` and</span>
<span class="sd">        :math:`\\boldsymbol{Y&#39;}` are points of the microscale reference</span>
<span class="sd">        configuration (:math:`\\Omega_{\\mu,\\,0}`), :math:`\\chi^{(I)}` is the</span>
<span class="sd">        characteristic function of the :math:`I` th material cluster,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{\\Phi}}^{0}` is the reference material</span>
<span class="sd">        Green operator (fourth-order tensor), and :math:`n_{c}` is the number</span>
<span class="sd">        of material clusters.</span>

<span class="sd">        The detailed description of the custer interaction tensors can</span>
<span class="sd">        be found in Section 4.3 of Ferreira (2022) [#]_.</span>

<span class="sd">        .. [#] Ferreira, B.P. (2022). *Towards Data-driven Multi-scale</span>
<span class="sd">               Optimization of Thermoplastic Blends: Microstructural</span>
<span class="sd">               Generation, Constitutive Development and Clustering-based</span>
<span class="sd">               Reduced-Order Modeling.* PhD Thesis, University of Porto</span>
<span class="sd">               (see `here &lt;https://repositorio-aberto.up.pt/handle/10216/</span>
<span class="sd">               146900?locale=en&gt;`_)</span>

<span class="sd">        ----</span>

<span class="sd">        *Adaptive update of cluster interaction matrix:*</span>

<span class="sd">        The cluster interaction tensors `adaptive` computation mode can only be</span>
<span class="sd">        performed after at least one `full` computation has been performed.</span>

<span class="sd">        A detailed description of the `adaptive` update of the cluster</span>
<span class="sd">        interaction matrix can be found in Section 2.3.3 of</span>
<span class="sd">        Ferreira et. al (2022) [#]_.</span>

<span class="sd">        .. [#] Ferreira, B.P., Andrade Pires, F.M. and Bessa, M.A. (2022).</span>
<span class="sd">               *Adaptivity for clustering-based reduced-order modeling of</span>
<span class="sd">               localized history-dependent phenomena.* Comp Methods Appl M, 393</span>
<span class="sd">               (see `here &lt;https://www.sciencedirect.com/science/article/pii/</span>
<span class="sd">               S0045782522000895?via%3Dihub&gt;`_)</span>

<span class="sd">        ----</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : {&#39;full&#39;, &#39;adaptive&#39;}, default=&#39;full&#39;</span>
<span class="sd">            The default `full` mode performs the complete computation of all</span>
<span class="sd">            cluster interaction tensors. The &#39;adaptive&#39; mode speeds up the</span>
<span class="sd">            computation of the new cluster interaction tensors resulting from</span>
<span class="sd">            an adaptive clustering characterized by `adaptive_clustering_map`.</span>
<span class="sd">        adaptive_clustering_map : dict</span>
<span class="sd">            Adaptive clustering map (item, dict with list of new cluster labels</span>
<span class="sd">            (item, list[int]) resulting from the refinement of each target</span>
<span class="sd">            cluster (key, str)) for each material phase (key, str). Required in</span>
<span class="sd">            `adaptive` mode, otherwise ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check parameters</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="s1">&#39;adaptive&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown mode to compute cluster interaction &#39;</span>
                               <span class="s1">&#39;tensors.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;adaptive&#39;</span> <span class="ow">and</span> <span class="n">adaptive_clustering_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Adaptive clustering map must be provided in &#39;</span>
                               <span class="s1">&#39;`adaptive` mode.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Perform mode-specific initialization procedures</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span>
            <span class="n">info</span><span class="o">.</span><span class="n">displayinfo</span><span class="p">(</span><span class="s1">&#39;5&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;Computing CRVE cluster interaction tensors...&#39;</span><span class="p">)</span>
            <span class="c1"># Initialize cluster interaction tensors dictionary</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">mat_phase_B</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">mat_phase_A</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span><span class="p">)):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">mat_phase_A</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">mat_phase_B</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># Compute Green operator material independent terms</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gop_X_dft_vox</span> <span class="o">=</span> <span class="n">citop</span><span class="o">.</span><span class="n">gop_material_independent_terms</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_problem_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rve_dims</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_n_voxels_dims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;adaptive&#39;</span><span class="p">:</span>
            <span class="n">init_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="c1"># Build lists with old (preexistent) clusters and new (adapted)</span>
            <span class="c1"># clusters for each material phase. Also get list of clusters that</span>
            <span class="c1"># no longer exist due to clustering adaptivity</span>
            <span class="n">phase_old_clusters</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">phase_new_clusters</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">pop_clusters</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mat_phase</span> <span class="ow">in</span> <span class="n">adaptive_clustering_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">phase_new_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="nb">sum</span><span class="p">(</span><span class="n">adaptive_clustering_map</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="p">[])</span>
                    <span class="n">pop_clusters</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="n">adaptive_clustering_map</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">phase_new_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">phase_old_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_phase_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">])</span>
                    <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">phase_new_clusters</span><span class="p">[</span><span class="n">mat_phase</span><span class="p">]))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over material phases</span>
        <span class="k">for</span> <span class="n">mat_phase_B</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
            <span class="c1"># Set material phase B clusters to be looped over</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span>
                <span class="n">clusters_J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phase_clusters</span><span class="p">[</span><span class="n">mat_phase_B</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;adaptive&#39;</span><span class="p">:</span>
                <span class="n">clusters_J</span> <span class="o">=</span> <span class="n">phase_new_clusters</span><span class="p">[</span><span class="n">mat_phase_B</span><span class="p">]</span>
            <span class="c1"># Loop over material phase B clusters</span>
            <span class="k">for</span> <span class="n">cluster_J</span> <span class="ow">in</span> <span class="n">clusters_J</span><span class="p">:</span>
                <span class="c1"># Set material phase B cluster characteristic function</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">cluster_J_filter_dft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_filter</span><span class="p">(</span><span class="n">cluster_J</span><span class="p">)</span>
                <span class="c1"># Perform discrete convolution between the material phase B</span>
                <span class="c1"># cluster characteristic function and each of Green operator</span>
                <span class="c1"># material independent terms</span>
                <span class="n">gop_X_filt_vox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gop_convolution</span><span class="p">(</span><span class="n">cluster_J_filter_dft</span><span class="p">,</span>
                                                       <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_gop_X_dft_vox</span><span class="p">)</span>
                <span class="c1"># Loop over material phases</span>
                <span class="k">for</span> <span class="n">mat_phase_A</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
                    <span class="c1"># Set material phase pair dictionary</span>
                    <span class="n">mat_phase_pair</span> <span class="o">=</span> <span class="n">mat_phase_A</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">mat_phase_B</span>
                    <span class="c1"># Loop over material phase A clusters</span>
                    <span class="k">for</span> <span class="n">cluster_I</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_phase_clusters</span><span class="p">[</span><span class="n">mat_phase_A</span><span class="p">]:</span>
                        <span class="c1"># Set material cluster pair</span>
                        <span class="n">cluster_pair</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_I</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_J</span><span class="p">)</span>
                        <span class="c1"># Check if cluster-symmetric cluster interaction tensor</span>
                        <span class="n">sym_cluster_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_switch_pair</span><span class="p">(</span><span class="n">cluster_pair</span><span class="p">)</span>
                        <span class="n">sym_mat_phase_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_switch_pair</span><span class="p">(</span><span class="n">mat_phase_pair</span><span class="p">)</span>
                        <span class="n">is_clst_sym</span> <span class="o">=</span> <span class="n">sym_cluster_pair</span> <span class="ow">in</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sym_mat_phase_pair</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                        <span class="c1"># Compute cluster interaction tensor between material</span>
                        <span class="c1"># phase A cluster and material phase B cluster</span>
                        <span class="c1"># (complete computation or cluster-symmetric</span>
                        <span class="c1"># computation)</span>
                        <span class="k">if</span> <span class="n">is_clst_sym</span><span class="p">:</span>
                            <span class="c1"># Set cluster volume fractions ratio</span>
                            <span class="n">clst_vf_ratio</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_clusters_vf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster_J</span><span class="p">)]</span>
                                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusters_vf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster_I</span><span class="p">)])</span>
                            <span class="c1"># Compute clustering interaction tensor between</span>
                            <span class="c1"># material phase A cluster and material phase B</span>
                            <span class="c1"># cluster through cluster-symmetry</span>
                            <span class="k">for</span> <span class="n">cit_mf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span><span class="p">:</span>
                                <span class="n">cit_mf</span><span class="p">[</span><span class="n">mat_phase_pair</span><span class="p">][</span><span class="n">cluster_pair</span><span class="p">]</span> <span class="o">=</span> \
                                    <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">clst_vf_ratio</span><span class="p">,</span>
                                                <span class="n">cit_mf</span><span class="p">[</span><span class="n">sym_mat_phase_pair</span><span class="p">][</span>
                                                    <span class="n">sym_cluster_pair</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># Set material phase A cluster characteristic</span>
                            <span class="c1"># function</span>
                            <span class="n">cluster_I_filter</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">_cluster_filter</span><span class="p">(</span><span class="n">cluster_I</span><span class="p">)</span>
                            <span class="c1"># Perform discrete integral over the spatial domain</span>
                            <span class="c1"># of material phase A cluster I</span>
                            <span class="n">cit_X_integral_mf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discrete_cit_integral</span><span class="p">(</span>
                                <span class="n">cluster_I_filter</span><span class="p">,</span> <span class="o">*</span><span class="n">gop_X_filt_vox</span><span class="p">)</span>
                            <span class="c1"># Compute cluster interaction tensor between the</span>
                            <span class="c1"># material phase A cluster and the material phase B</span>
                            <span class="c1"># cluster</span>
                            <span class="n">rve_vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rve_dims</span><span class="p">)</span>
                            <span class="n">factor</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_clusters_vf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster_I</span><span class="p">)]</span>
                                          <span class="o">*</span> <span class="n">rve_vol</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span><span class="p">)):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">mat_phase_pair</span><span class="p">][</span>
                                    <span class="n">cluster_pair</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                                        <span class="n">factor</span><span class="p">,</span> <span class="n">cit_X_integral_mf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Compute remaining adaptive cluster interaction tensors through</span>
        <span class="c1"># cluster-symmetry and remove vanished clustering interaction tensors</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;adaptive&#39;</span><span class="p">:</span>
            <span class="c1"># Loop over material phases</span>
            <span class="k">for</span> <span class="n">mat_phase_B</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
                <span class="c1"># Loop over material phase B old clusters</span>
                <span class="k">for</span> <span class="n">cluster_J</span> <span class="ow">in</span> <span class="n">phase_old_clusters</span><span class="p">[</span><span class="n">mat_phase_B</span><span class="p">]:</span>
                    <span class="c1"># Loop over material phases</span>
                    <span class="k">for</span> <span class="n">mat_phase_A</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
                        <span class="c1"># Set material phase pair dictionary</span>
                        <span class="n">mat_phase_pair</span> <span class="o">=</span> <span class="n">mat_phase_A</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">mat_phase_B</span>
                        <span class="c1"># Loop over material phase A new clusters</span>
                        <span class="k">for</span> <span class="n">cluster_I</span> <span class="ow">in</span> <span class="n">phase_new_clusters</span><span class="p">[</span><span class="n">mat_phase_A</span><span class="p">]:</span>
                            <span class="c1"># Set material cluster pair</span>
                            <span class="n">cluster_pair</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_I</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> \
                                <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">cluster_J</span><span class="p">)</span>
                            <span class="c1"># Check if cluster-symmetric cluster interaction</span>
                            <span class="c1"># tensor</span>
                            <span class="n">sym_cluster_pair</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_switch_pair</span><span class="p">(</span><span class="n">cluster_pair</span><span class="p">)</span>
                            <span class="n">sym_mat_phase_pair</span> <span class="o">=</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">_switch_pair</span><span class="p">(</span><span class="n">mat_phase_pair</span><span class="p">)</span>
                            <span class="n">is_clst_sym</span> <span class="o">=</span> <span class="n">sym_cluster_pair</span> <span class="ow">in</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">sym_mat_phase_pair</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                            <span class="c1"># Compute cluster interaction tensor between</span>
                            <span class="c1"># material phase A cluster and material phase B</span>
                            <span class="c1"># cluster through cluster-symmetry</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_clst_sym</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                                    <span class="s1">&#39;All the remaining adaptive clustering &#39;</span>
                                    <span class="s1">&#39;interaction tensors should be &#39;</span>
                                    <span class="s1">&#39;cluster-symmetric.&#39;</span><span class="p">)</span>
                            <span class="c1"># Set cluster volume fractions ratio</span>
                            <span class="n">clst_vf_ratio</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_clusters_vf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster_J</span><span class="p">)]</span>
                                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clusters_vf</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">cluster_I</span><span class="p">)])</span>
                            <span class="c1"># Compute clustering interaction tensor</span>
                            <span class="k">for</span> <span class="n">cit_mf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span><span class="p">:</span>
                                <span class="n">cit_mf</span><span class="p">[</span><span class="n">mat_phase_pair</span><span class="p">][</span><span class="n">cluster_pair</span><span class="p">]</span> <span class="o">=</span> \
                                    <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">clst_vf_ratio</span><span class="p">,</span>
                                                <span class="n">cit_mf</span><span class="p">[</span><span class="n">sym_mat_phase_pair</span><span class="p">][</span>
                                                    <span class="n">sym_cluster_pair</span><span class="p">])</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Loop over material phases</span>
            <span class="k">for</span> <span class="n">mat_phase_B</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
                <span class="c1"># Loop over material phases</span>
                <span class="k">for</span> <span class="n">mat_phase_A</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_material_phases</span><span class="p">:</span>
                    <span class="c1"># Set material phase pair dictionary</span>
                    <span class="n">mat_phase_pair</span> <span class="o">=</span> <span class="n">mat_phase_A</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">mat_phase_B</span>
                    <span class="c1"># Set existent cluster interactions</span>
                    <span class="n">cluster_pairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span>
                                     <span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mat_phase_pair</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
                    <span class="c1"># Loop over cluster pairs</span>
                    <span class="k">for</span> <span class="n">cluster_pair</span> <span class="ow">in</span> <span class="n">cluster_pairs</span><span class="p">:</span>
                        <span class="n">cluster_I</span> <span class="o">=</span> <span class="n">cluster_pair</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">cluster_J</span> <span class="o">=</span> <span class="n">cluster_pair</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="c1"># If any of the interacting clusters no longer exists,</span>
                        <span class="c1"># then remove the associated cluster interaction tensor</span>
                        <span class="k">if</span> <span class="n">cluster_I</span> <span class="ow">in</span> <span class="n">pop_clusters</span> \
                                <span class="ow">or</span> <span class="n">cluster_J</span> <span class="ow">in</span> <span class="n">pop_clusters</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span><span class="p">)):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_cit_x_mf</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">mat_phase_pair</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
                                    <span class="n">cluster_pair</span><span class="p">)</span>
            <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
            <span class="c1"># Update total amount of time spent in clustering adaptivity</span>
            <span class="c1"># cluster interaction tensors computation procedures</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_adaptive_cit_time</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">init_time</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE._cluster_filter"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE._cluster_filter">[docs]</a>    <span class="k">def</span> <span class="nf">_cluster_filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute cluster discrete characteristic function.</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\chi^{(I)} (\\boldsymbol{Y}) = \\begin{cases} 1 \\quad \\text{if}</span>
<span class="sd">           \\; \\; \\; \\boldsymbol{Y}\\in \\Omega^{(I)}_{\\mu, \\, 0} \\\\ 0</span>
<span class="sd">           \\quad \\text{otherwise} \\end{cases}</span>

<span class="sd">        where :math:`\\chi^{(I)}` is the</span>
<span class="sd">        characteristic function of the :math:`I` th material cluster and</span>
<span class="sd">        :math:`\\boldsymbol{Y}` is a point of the microscale reference</span>
<span class="sd">        configuration (:math:`\\Omega_{\\mu,\\,0}`).</span>

<span class="sd">        The detailed description of the cluster characteristic function can</span>
<span class="sd">        be found in Section 4.3.1 of Ferreira (2022) [#]_.</span>

<span class="sd">        .. [#] Ferreira, B.P. (2022). *Towards Data-driven Multi-scale</span>
<span class="sd">               Optimization of Thermoplastic Blends: Microstructural</span>
<span class="sd">               Generation, Constitutive Development and Clustering-based</span>
<span class="sd">               Reduced-Order Modeling.* PhD Thesis, University of Porto</span>
<span class="sd">               (see `here &lt;https://repositorio-aberto.up.pt/handle/10216/</span>
<span class="sd">               146900?locale=en&gt;`_)</span>

<span class="sd">        ----</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster : int</span>
<span class="sd">            Cluster label.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cluster_filter : numpy.ndarray[bool] (2d or 3d)</span>
<span class="sd">            Cluster discrete characteristic function in spatial domain.</span>
<span class="sd">        cluster_filter_dft : numpy.ndarray</span>
<span class="sd">            Cluster discrete characteristic function in frequency domain</span>
<span class="sd">            (discrete Fourier transform).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if valid cluster</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cluster label must be an integer.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cluster</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Cluster label does not exist in the CRVE.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Build cluster filter (spatial domain)</span>
        <span class="n">cluster_filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_voxels_clusters</span> <span class="o">==</span> <span class="n">cluster</span>
        <span class="c1"># Perform Discrete Fourier Transform (DFT) by means of Fast Fourier</span>
        <span class="c1"># Transform (FFT)</span>
        <span class="n">cluster_filter_dft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">(</span><span class="n">cluster_filter</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">cluster_filter</span><span class="p">,</span> <span class="n">cluster_filter_dft</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE._gop_convolution"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE._gop_convolution">[docs]</a>    <span class="k">def</span> <span class="nf">_gop_convolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_filter_dft</span><span class="p">,</span> <span class="n">gop_1_dft_vox</span><span class="p">,</span>
                         <span class="n">gop_2_dft_vox</span><span class="p">,</span> <span class="n">gop_0_freq_dft_vox</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convolution of cluster characteristic function and Green operator.</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\int_{\\Omega_{\\mu, \\, 0}} \\chi^{(J)} (\\boldsymbol{Y}&#39;) \\,</span>
<span class="sd">           \\boldsymbol{\\mathsf{\\Phi}}^{0} (\\boldsymbol{Y} -</span>
<span class="sd">           \\boldsymbol{Y}&#39;) \\, \\mathrm{d} v&#39; = \\mathscr{F}^{-1} \\left(</span>
<span class="sd">           \\breve{\\chi}^{(J)}(\\boldsymbol{\\zeta}) \\,</span>
<span class="sd">           \\breve{\\boldsymbol{\\mathsf{\\Phi}}}^{0} (\\boldsymbol{\\zeta})</span>
<span class="sd">           \\right) \\, ,</span>

<span class="sd">        where :math:`\\chi^{(J)}` is the characteristic function of the</span>
<span class="sd">        :math:`J` th material cluster,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{\\Phi}}^{0}` is the reference material</span>
<span class="sd">        Green operator (fourth-order tensor), :math:`\\boldsymbol{Y}` and</span>
<span class="sd">        :math:`\\boldsymbol{Y&#39;}` are points of the microscale reference</span>
<span class="sd">        configuration (:math:`\\Omega_{\\mu,\\,0}`), and</span>
<span class="sd">        :math:`\\boldsymbol{\\zeta}` is the frequency wave vector. The operator</span>
<span class="sd">        :math:`\\mathscr{F}^{-1}(\\cdot)` denotes the inverse Fourier transform</span>
<span class="sd">        and :math:`\\breve{(\\cdot)}` denotes a field defined in the frequency</span>
<span class="sd">        domain.</span>

<span class="sd">        Such a computation is required to compute the cluster interaction</span>
<span class="sd">        tensors. More information can be found in Ferreira (2022) [#]_</span>
<span class="sd">        (see Equations (4.111) and surrounding text).</span>

<span class="sd">        .. [#] Ferreira, B.P. (2022). *Towards Data-driven Multi-scale</span>
<span class="sd">               Optimization of Thermoplastic Blends: Microstructural</span>
<span class="sd">               Generation, Constitutive Development and Clustering-based</span>
<span class="sd">               Reduced-Order Modeling.* PhD Thesis, University of Porto</span>
<span class="sd">               (see `here &lt;https://repositorio-aberto.up.pt/handle/10216/</span>
<span class="sd">               146900?locale=en&gt;`_)</span>

<span class="sd">        ----</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster_filter_dft : numpy.ndarray</span>
<span class="sd">            Cluster discrete characteristic function in frequency domain</span>
<span class="sd">            (discrete Fourier transform).</span>
<span class="sd">        gop_1_dft_vox : dict</span>
<span class="sd">            Regular grid shaped matrix (item, numpy.ndarray) containing each</span>
<span class="sd">            fourth-order matricial form component (key, str) of the first Green</span>
<span class="sd">            operator material independent term in the frequency domain</span>
<span class="sd">            (discrete Fourier transform).</span>
<span class="sd">        gop_2_dft_vox : dict</span>
<span class="sd">            Regular grid shaped matrix (item, numpy.ndarray) containing each</span>
<span class="sd">            fourth-order matricial form component (key, str) of the second</span>
<span class="sd">            Green operator material independent term in the frequency domain</span>
<span class="sd">            (discrete Fourier transform).</span>
<span class="sd">        gop_0_freq_dft_vox : dict</span>
<span class="sd">            Regular grid shaped matrix (item, numpy.ndarray) containing each</span>
<span class="sd">            fourth-order matricial form component (key, str) of the Green</span>
<span class="sd">            operator zero-frequency (material independent) term in the</span>
<span class="sd">            frequency domain (discrete Fourier transform).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gop_1_filt_vox : dict</span>
<span class="sd">            Regular grid shaped matrix (item, numpy.ndarray) containing each</span>
<span class="sd">            fourth-order matricial form component (key, str) of the convolution</span>
<span class="sd">            between the material cluster characteristic function and the</span>
<span class="sd">            first Green operator material independent term in the spatial</span>
<span class="sd">            domain (inverse discrete Fourier transform).</span>
<span class="sd">        gop_2_filt_vox : dict</span>
<span class="sd">            Regular grid shaped matrix (item, numpy.ndarray) containing each</span>
<span class="sd">            fourth-order matricial form component (key, str) of the convolution</span>
<span class="sd">            between the material cluster characteristic function and the</span>
<span class="sd">            second Green operator materia independent term in the spatial</span>
<span class="sd">            domain (inverse discrete Fourier transform).</span>
<span class="sd">        gop_0_freq_filt_vox : dict</span>
<span class="sd">            Regular grid shaped matrix (item, numpy.ndarray) containing each</span>
<span class="sd">            fourth-order matricial form component (key, str) of the convolution</span>
<span class="sd">            between the material cluster characteristic function and the</span>
<span class="sd">            zero-frequency Green operator (material independent) term in the</span>
<span class="sd">            spatial domain (inverse discrete Fourier transform).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set strain/stress components order according to problem strain</span>
        <span class="c1"># formulation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown problem strain formulation.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize discrete convolution (spatial and frequency domain)</span>
        <span class="n">gop_1_filt_dft_vox</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">gop_1_dft_vox</span><span class="p">)</span>
        <span class="n">gop_2_filt_dft_vox</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">gop_2_dft_vox</span><span class="p">)</span>
        <span class="n">gop_0_freq_filt_dft_vox</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">gop_0_freq_dft_vox</span><span class="p">)</span>
        <span class="n">gop_1_filt_vox</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">gop_1_dft_vox</span><span class="p">)</span>
        <span class="n">gop_2_filt_vox</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">gop_1_dft_vox</span><span class="p">)</span>
        <span class="n">gop_0_freq_filt_vox</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">gop_1_dft_vox</span><span class="p">)</span>
        <span class="c1"># Compute RVE volume and total number of voxels</span>
        <span class="n">rve_vol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rve_dims</span><span class="p">)</span>
        <span class="n">n_voxels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_voxels_dims</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over Green operator components</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)):</span>
            <span class="n">compi</span> <span class="o">=</span> <span class="n">comp_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)):</span>
                <span class="n">compj</span> <span class="o">=</span> <span class="n">comp_order</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="c1"># Perform discrete convolution in the frequency domain</span>
                <span class="n">gop_1_filt_dft_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">((</span><span class="n">rve_vol</span><span class="o">/</span><span class="n">n_voxels</span><span class="p">),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">cluster_filter_dft</span><span class="p">,</span>
                                            <span class="n">gop_1_filt_dft_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]))</span>
                <span class="n">gop_2_filt_dft_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">((</span><span class="n">rve_vol</span><span class="o">/</span><span class="n">n_voxels</span><span class="p">),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">cluster_filter_dft</span><span class="p">,</span>
                                            <span class="n">gop_2_filt_dft_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]))</span>
                <span class="n">gop_0_freq_filt_dft_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">((</span><span class="n">rve_vol</span><span class="o">/</span><span class="n">n_voxels</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                        <span class="n">cluster_filter_dft</span><span class="p">,</span>
                        <span class="n">gop_0_freq_filt_dft_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]))</span>
                <span class="c1"># Perform an Inverse Discrete Fourier Transform (IDFT) by means</span>
                <span class="c1"># of Fast Fourier Transform (FFT)</span>
                <span class="n">gop_1_filt_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">gop_1_filt_dft_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]))</span>
                <span class="n">gop_2_filt_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span><span class="n">gop_2_filt_dft_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]))</span>
                <span class="n">gop_0_freq_filt_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">(</span>
                    <span class="n">gop_0_freq_filt_dft_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">gop_1_filt_vox</span><span class="p">,</span> <span class="n">gop_2_filt_vox</span><span class="p">,</span> <span class="n">gop_0_freq_filt_vox</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE._discrete_cit_integral"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE._discrete_cit_integral">[docs]</a>    <span class="k">def</span> <span class="nf">_discrete_cit_integral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cluster_filter</span><span class="p">,</span> <span class="n">gop_1_filt_vox</span><span class="p">,</span>
                               <span class="n">gop_2_filt_vox</span><span class="p">,</span> <span class="n">gop_0_freq_filt_vox</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Discrete integral over the spatial domain of material cluster.</span>

<span class="sd">        .. math::</span>

<span class="sd">           \\int_{\\Omega_{\\mu, 0}} \\chi^{(I)}(\\boldsymbol{Y}) \\left(</span>
<span class="sd">           \\int_{\\Omega_{\\mu, 0}}  \\, \\chi^{(J)}(\\boldsymbol{Y}) \\,</span>
<span class="sd">           \\boldsymbol{\\Phi}^{0}(\\boldsymbol{Y}-\\boldsymbol{Y}&#39;) \\,</span>
<span class="sd">           \\mathrm{d}v&#39; \\right) \\mathrm{d}v \\, ,</span>

<span class="sd">        where :math:`\\chi^{(I)}` is the characteristic function of the</span>
<span class="sd">        :math:`I` th material cluster,</span>
<span class="sd">        :math:`\\boldsymbol{\\mathsf{\\Phi}}^{0}` is the reference material</span>
<span class="sd">        Green operator (fourth-order tensor), and :math:`\\boldsymbol{Y}` and</span>
<span class="sd">        :math:`\\boldsymbol{Y&#39;}` are points of the microscale reference</span>
<span class="sd">        configuration (:math:`\\Omega_{\\mu,\\,0}`).</span>

<span class="sd">        Such a computation is required to compute the cluster interaction</span>
<span class="sd">        tensors. More information can be found in Ferreira (2022) [#]_</span>
<span class="sd">        (see Equations (4.112) and surrounding text).</span>

<span class="sd">        .. [#] Ferreira, B.P. (2022). *Towards Data-driven Multi-scale</span>
<span class="sd">               Optimization of Thermoplastic Blends: Microstructural</span>
<span class="sd">               Generation, Constitutive Development and Clustering-based</span>
<span class="sd">               Reduced-Order Modeling.* PhD Thesis, University of Porto</span>
<span class="sd">               (see `here &lt;https://repositorio-aberto.up.pt/handle/10216/</span>
<span class="sd">               146900?locale=en&gt;`_)</span>

<span class="sd">        ----</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cluster_filter : numpy.ndarray</span>
<span class="sd">            Cluster discrete characteristic function in spatial domain.</span>
<span class="sd">        gop_1_filt_vox : dict</span>
<span class="sd">            Regular grid shaped matrix (item, numpy.ndarray) containing each</span>
<span class="sd">            fourth-order matricial form component (key, str) of the convolution</span>
<span class="sd">            between the material cluster characteristic function and the first</span>
<span class="sd">            Green operator material independent term in the spatial domain</span>
<span class="sd">            (inverse discrete Fourier transform).</span>
<span class="sd">        gop_2_filt_vox : dict</span>
<span class="sd">            Regular grid shaped matrix (item, numpy.ndarray) containing each</span>
<span class="sd">            fourth-order matricial form component (key, str) of the convolution</span>
<span class="sd">            between the material cluster characteristic function and the second</span>
<span class="sd">            Green operator material independent term in the spatial domain</span>
<span class="sd">            (inverse discrete Fourier transform).</span>
<span class="sd">        gop_0_freq_filt_vox : dict</span>
<span class="sd">            Regular grid shaped matrix (item, numpy.ndarray) containing each</span>
<span class="sd">            fourth-order matricial form component (key, str) of the convolution</span>
<span class="sd">            between the material cluster characteristic function and the</span>
<span class="sd">            zero-frequency Green operator (material independent) term in the</span>
<span class="sd">            spatial domain (inverse discrete Fourier transform).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cit_1_integral_mf : numpy.ndarray (2d)</span>
<span class="sd">            Discrete integral over the spatial domain of material cluster I of</span>
<span class="sd">            the discrete convolution between the material cluster J</span>
<span class="sd">            characteristic function and the first Green operator material</span>
<span class="sd">            independent term in the spatial domain (numpy.ndarray of shape</span>
<span class="sd">            (n_comps, n_comps)).</span>
<span class="sd">        cit_2_integral_mf : numpy.ndarray (2d)</span>
<span class="sd">            Discrete integral over the spatial domain of material cluster I of</span>
<span class="sd">            the discrete convolution between the material cluster J</span>
<span class="sd">            characteristic function and the second Green operator material</span>
<span class="sd">            independent term in the spatial domain (numpy.ndarray of shape</span>
<span class="sd">            (n_comps, n_comps)).</span>
<span class="sd">        cit_0_freq_integral_mf : numpy.ndarray (2d)</span>
<span class="sd">            Discrete integral over the spatial domain of material cluster I of</span>
<span class="sd">            the discrete convolution between the material cluster J</span>
<span class="sd">            characteristic function and the zero-frequency Green operator</span>
<span class="sd">            (material independent) term in the spatial domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Set strain/stress components order according to problem strain</span>
        <span class="c1"># formulation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;infinitesimal&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_sym</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strain_formulation</span> <span class="o">==</span> <span class="s1">&#39;finite&#39;</span><span class="p">:</span>
            <span class="n">comp_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comp_order_nsym</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Unknown problem strain formulation.&#39;</span><span class="p">)</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Initialize discrete integral</span>
        <span class="n">cit_1_integral_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)))</span>
        <span class="n">cit_2_integral_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)))</span>
        <span class="n">cit_0_freq_integral_mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="c1"># Loop over matricial form components</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)):</span>
            <span class="n">compi</span> <span class="o">=</span> <span class="n">comp_order</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">comp_order</span><span class="p">)):</span>
                <span class="n">compj</span> <span class="o">=</span> <span class="n">comp_order</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="c1"># Perform discrete integral over the spatial domain of material</span>
                <span class="c1"># cluster I</span>
                <span class="n">cit_1_integral_mf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mop</span><span class="o">.</span><span class="n">kelvin_factor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span> \
                    <span class="o">*</span> <span class="n">mop</span><span class="o">.</span><span class="n">kelvin_factor</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span> \
                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">cluster_filter</span><span class="p">,</span>
                                         <span class="n">gop_1_filt_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]))</span>
                <span class="n">cit_2_integral_mf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">mop</span><span class="o">.</span><span class="n">kelvin_factor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span> \
                    <span class="o">*</span> <span class="n">mop</span><span class="o">.</span><span class="n">kelvin_factor</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span> \
                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">cluster_filter</span><span class="p">,</span>
                                         <span class="n">gop_2_filt_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]))</span>
                <span class="n">cit_0_freq_integral_mf</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">mop</span><span class="o">.</span><span class="n">kelvin_factor</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span> \
                    <span class="o">*</span> <span class="n">mop</span><span class="o">.</span><span class="n">kelvin_factor</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">comp_order</span><span class="p">)</span> \
                    <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">cluster_filter</span><span class="p">,</span>
                                         <span class="n">gop_0_freq_filt_vox</span><span class="p">[</span><span class="n">compi</span> <span class="o">+</span> <span class="n">compj</span><span class="p">]))</span>
        <span class="c1"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
        <span class="k">return</span> <span class="n">cit_1_integral_mf</span><span class="p">,</span> <span class="n">cit_2_integral_mf</span><span class="p">,</span> <span class="n">cit_0_freq_integral_mf</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE._switch_pair"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE._switch_pair">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_switch_pair</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Switch left and right sides of string with separating delimiter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : str</span>
<span class="sd">            Target string.</span>
<span class="sd">        delimiter : str, default=&#39;_&#39;</span>
<span class="sd">            Separating delimiter between target&#39;s string left and right sides.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        y : str</span>
<span class="sd">            Switched string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Input parameter must be a string and can &#39;</span>
                               <span class="s1">&#39;only contain one delimiter.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">delimiter</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span></div>
    <span class="c1"># -------------------------------------------------------------------------</span>
<div class="viewcode-block" id="CRVE.save_crve_file"><a class="viewcode-back" href="../../_autosummary/crate.main.CRVE.html#crate.ioput.readprocedures.CRVE.save_crve_file">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">save_crve_file</span><span class="p">(</span><span class="n">crve</span><span class="p">,</span> <span class="n">crve_file_path</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dump CRVE into file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crve : CRVE</span>
<span class="sd">            Cluster-Reduced Representative Volume Element.</span>
<span class="sd">        crve_file_path : str</span>
<span class="sd">            Path of file where the CRVE&#39;s instance is dumped.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Dump CRVE instance into file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">crve_file_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">crve_file</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">crve</span><span class="p">,</span> <span class="n">crve_file</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Bernardo Ferreira.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>